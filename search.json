[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule Fall 2025",
    "section": "",
    "text": "Date\n#\nLecture\nTopic\n\n\n\n\n24/09/2025\n1\nNo Class\n\n\n\n01/10/2025\n2\nLecture 01\nIntroduction to Python\n\n\n\n\nLecture 02\nData types and structures\n\n\n08/10/2025\n3\nLecture 03\nControl structures\n\n\n\n\nLecture 04\nFunctions\n\n\n15/10/2025\n4\nLecture 05\nObject Oriented Programming\n\n\n\n\nLecture 06\nLibraries\n\n\n22/10/2025\n5\nLecture 07\nNumerical computing\n\n\n\n\nLecture 08\nData manipulation\n\n\n29/10/2025\n6\nRecap\n\n\n\n05/11/2025\n7\nLecture 09\nInput/output\n\n\n\n\nLecture 10\nData visualization\n\n\n12/11/2025\n8\nLecture 11  [Guest Lecture]\nNetwork analytics\n\n\n19/11/2025\n9\nLecture 12\nTime series analysis\n\n\n26/11/2025\n10\nLecture 13\nMachine Learning\n\n\n03/12/2025\n11\nRecap\n\n\n\n10/12/2025\n12\nLecture 14  [Guest Lecture]\nAdvanced Machine Learning\n\n\n17/12/2025\n13\nQ&A"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03_problem_sets.html",
    "href": "lectures/lecture_03/lecture_03_problem_sets.html",
    "title": "Controle Structures - Problem Set",
    "section": "",
    "text": "Write a Python program that takes a user’s income and tax status as input. If the income is greater than $50,000, they should be taxed at 25%. Otherwise, they are taxed at 15%. Print the amount of tax they owe.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03_problem_sets.html#more-exercises-on-list-comprehension",
    "href": "lectures/lecture_03/lecture_03_problem_sets.html#more-exercises-on-list-comprehension",
    "title": "Controle Structures - Problem Set",
    "section": "More exercises on list comprehension",
    "text": "More exercises on list comprehension\n\nExercise 1: Convert Temperatures\nGiven a list of temperatures in Celsius, use list comprehension to convert them to Fahrenheit. The formula for conversion is:\n\\[\n    F = \\frac{9}{5} \\times C + 32\n\\]\n\ncelsius = [0, 20, 37, 100]\n# Write the list comprehension to convert celsius to fahrenheit\n\n\n\nExercise 2: Filter and Square Odd Numbers\nGiven a list of numbers, use list comprehension to create a new list containing the squares of the odd numbers only.\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# Write the list comprehension to filter and square odd numbers\n\n\n\nExercise 3: Extract Vowels from a String\nGiven a string, use list comprehension to create a list of all the vowels in the string.\n\ntext = \"List comprehensions are very powerful!\"\n# Write the list comprehension to extract vowels from the string\n\n\n\nExercise 4: Flatten a Nested List\nGiven a list of lists (nested list), use list comprehension to flatten it into a single list.\n\nnested_list = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\n# Write the list comprehension to flatten the nested list\n\n\n\nExercise 5: Dictionary from List\nYou have a list of tuples where the first element is a country and the second element is its population. Use list comprehension to convert the list of tuples into a dictionary.\n\ncountries = [(\"USA\", 331002651), (\"India\", 1380004385), (\"China\", 1439323776)]\n# Write the list comprehension to convert the list into a dictionary"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04_problem_sets.html",
    "href": "lectures/lecture_04/lecture_04_problem_sets.html",
    "title": "Functions - Problem Set",
    "section": "",
    "text": "Exercise 1: Greeting Function\nWrite a function called greet_user(name) that takes a person’s name as a parameter and prints a greeting message.\n\n# Your code\n\n\n\nExercise 2: Sum of Two Numbers\nCreate a function called sum_two_numbers(a, b) that takes two numbers as arguments and returns their sum.\n\n# Your code\n\n\n\nExercise 3: Convert Celsius to Fahrenheit\nWrite a function celsius_to_fahrenheit(celsius) that takes a temperature in Celsius and returns the temperature in Fahrenheit. Use the formula:\n\\[\n    F = \\frac{9}{5} \\times C + 32\n\\]\n\n# Your code\n\n\n\nExercise 4: Calculate Area of Circle\nCreate a function called calculate_circle_area(radius) that takes the radius of a circle and returns the area of the circle using the formula:\n\\[\n    A = \\pi \\times r^2\n\\]\n\n# Your code\n\n\n\nExercise 5: Simple Interest\nWrite a function calculate_simple_interest(principal, rate, time) that calculates simple interest and returns it. The formula is:\n\\[\n    \\text{Interest} = \\frac{P \\times R \\times T}{100}\n\\]\n\n# Your code\n\n\n\nExercise 6: Compound Interest\nModify the function calculate_compound_interest(principal, rate, time) to return both the compound interest and the total amount (principal + interest).\n\n# Your code\n\n\n\nExercise 7: Maximum of Three Numbers\nCreate a function max_of_three(a, b, c) that takes three numbers as input and returns the largest of the three.\n\n# Your code\n\n\n\nExercise 8: Check Even or Odd with Lambda\nUse a lambda function to check whether a number is even or odd. Write a function is_even_or_odd(number) that returns “even” if the number is even and “odd” if the number is odd.\n\n# Your code\n\n\n\nExercise 9: Sum of Squares using map()\nUse map() and a lambda function to create a list of squares of numbers from 1 to 10.\n\n# Your code\n\n\n\nExercise 10: Filter Positive Numbers\nWrite a function filter_positive(numbers) that takes a list of numbers and uses the filter() function to return a list of only positive numbers.\n\n# Your code\n\n\n\nAdvanced Exercise 1: Recursive Factorial Function\nWrite a recursive function factorial(n) that takes a number n and returns the factorial of n.\n\n# Your code\n\n\n\nAdvanced Exercise 2: Higher-Order Function for Applying Functions\nCreate a higher-order function apply_function(func, x) that takes a function and a value x, and applies the function to x twice.\n\n# Your code\n\n\n\nAdvanced Exercise 3: Net Present Value (NPV) with Lambda\nWrite a function calculate_npv(cash_flows, rate) that calculates the Net Present Value (NPV) of cash flows using a lambda function inside a list comprehension. Assume cash_flows is a list and rate is a constant discount rate.\n\n# Your code\n\n\n\nAdvanced Exercise 4: Zip and Sort\nWrite a function zip_and_sort(names, scores) that takes two lists: names (list of students’ names) and scores (list of their scores). Use zip() to combine the two lists into tuples, then return the list of students sorted by their scores in descending order.\n\n# Your code\n\n\n\nAdvanced Exercise 5: Reduce for Cumulative Product\nUse the reduce() function to write a function cumulative_product(numbers) that takes a list of numbers and returns their cumulative product.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html",
    "href": "lectures/lecture_04/lecture_04.html",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#lecture-material",
    "href": "lectures/lecture_04/lecture_04.html#lecture-material",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#recording",
    "href": "lectures/lecture_04/lecture_04.html#recording",
    "title": "Lecture 04 - Functions",
    "section": "Recording",
    "text": "Recording\n\n1. Intro\n\n \n\n\n\n2. Basics\n\n \n\n\n\n3. Functional Programming"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#problem-sets",
    "href": "lectures/lecture_04/lecture_04.html#problem-sets",
    "title": "Lecture 04 - Functions",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html",
    "href": "lectures/lecture_02/lecture_02.html",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#lecture-material",
    "href": "lectures/lecture_02/lecture_02.html#lecture-material",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#recording",
    "href": "lectures/lecture_02/lecture_02.html#recording",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "Recording",
    "text": "Recording\n\n1. Types\n\n \n\n\n\n2. Structures"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#problem-sets",
    "href": "lectures/lecture_02/lecture_02.html#problem-sets",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)\nSolutions (.pdf)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html",
    "href": "lectures/lecture_01/introduction_to_python.html",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its simplicity and readability.\nKey Features of Python\n\nEasy to Learn: Python’s syntax is straightforward.\nInterpreted Language: Python code is executed line by line, which makes debugging easier.\nDynamically Typed: You don’t need to declare variable types explicitly; Python handles it automatically.\nVersatile: Python is used in web development, data analysis, automation, and much more.\nHuge Ecosystem: Python has a large standard library and third-party modules for a wide variety of applications.\n\n\n\n\n\nData Handling: In finance, you often work with large datasets—Python’s libraries like pandas and NumPy are designed to handle and analyze financial data efficiently.\nAutomation: Python can automate repetitive tasks like data retrieval, report generation, and portfolio analysis.\nFinancial Modeling: Python is a great tool for building complex models such as forecasting, risk management, and pricing.\nIntegration with Data Science: Python is the most popular language for data science, offering extensive support for statistical analysis, machine learning, and data visualization."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#what-is-python",
    "href": "lectures/lecture_01/introduction_to_python.html#what-is-python",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its simplicity and readability.\nKey Features of Python\n\nEasy to Learn: Python’s syntax is straightforward.\nInterpreted Language: Python code is executed line by line, which makes debugging easier.\nDynamically Typed: You don’t need to declare variable types explicitly; Python handles it automatically.\nVersatile: Python is used in web development, data analysis, automation, and much more.\nHuge Ecosystem: Python has a large standard library and third-party modules for a wide variety of applications."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#why-python-for-finance",
    "href": "lectures/lecture_01/introduction_to_python.html#why-python-for-finance",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Data Handling: In finance, you often work with large datasets—Python’s libraries like pandas and NumPy are designed to handle and analyze financial data efficiently.\nAutomation: Python can automate repetitive tasks like data retrieval, report generation, and portfolio analysis.\nFinancial Modeling: Python is a great tool for building complex models such as forecasting, risk management, and pricing.\nIntegration with Data Science: Python is the most popular language for data science, offering extensive support for statistical analysis, machine learning, and data visualization."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#installing-a-python-environment",
    "href": "lectures/lecture_01/introduction_to_python.html#installing-a-python-environment",
    "title": "Lecture 01 - Introduction to Python",
    "section": "2.1 Installing a Python environment",
    "text": "2.1 Installing a Python environment\n\nPython\n\nDownload Python from the official website.\nInstallation includes the Python interpreter and Integrated Development Environment (IDLE) for coding.\n\n\n\nInstalling Anaconda\n\nAnaconda is a suite of useful tools and packages for Python development.\nDownload Anaconda from the official website\nOnce it is installed, confirm the following environments and packages are available:\n\nSpyder\nJupyter Notebook"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#running-python-code",
    "href": "lectures/lecture_01/introduction_to_python.html#running-python-code",
    "title": "Lecture 01 - Introduction to Python",
    "section": "2.2 Running Python Code",
    "text": "2.2 Running Python Code\nThere are multiple ways to run Python.\nConsider the following code line which instructs to simply print out “Hello World!”\n    print (\"Hello World!\")\n\nPython Shell\n\nUse the Python IDLE (from terminal of from any IDE setting like Spyder)\nType the code and press Enter\nCheck the output\n\n\n\nPython Script\n\nOpen an empty file (Spyder, Sublime Text Editor, etc.)\nWrite the code\nSave file as helloworld.py\nRun the script\n\nFrom the terminal, run the script by typing\n\n    python helloworld.py\n\nFrom the IDE (like Spyder), launch the run\n\nCheck the output\n\n\n\nNotebook\n\nThis is a Notebook\n\nPlatforms like Jupyter Notebooks are widely used in data science for documenting and running code interactively. - Open Jupyter Notebook by typing in the terminal\n    Jupyter Notebook\n\nCreat a new notebook with a Python environment\nWrite the code in the first cell\nRun the cell\nCheck the output (see below)\n\n\nprint ('Hello World!')"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#syntax",
    "href": "lectures/lecture_01/introduction_to_python.html#syntax",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.1 Syntax",
    "text": "3.1 Syntax\n\n3.1.1 Python as a calculator\n\n5000 + 250\n\n\n10000 * 1.05\n\n\n10000 / 2\n\nComments: Use comments (#) to explain code, particularly useful for documenting underlying logic.\n\n# Basic financial arithmetic\nprint(5000 + 250)    # Adding investment returns\nprint(10000 * 1.05)  # Calculating interest (5% growth)\nprint(10000 / 2) # Splitting an investment\n\n\n# This is a comment\nprint(\"Welcome to Python for Finance!\")  # This prints a message\n\n\n\n3.1.2 Variables and Data Types\n\nVariables\nVariables are store data for calculations\nThe operation = assigns a value to a variable.\n\n# Variable assignment in a financial scenario\nstock_price = 150.25  # Price of a stock\ninvestment_amount = 10000  # Amount invested\nshares = investment_amount / stock_price  # Number of shares\n\n\nshares\n\n\n\nData types\nVariables can be of different types.\n\nStrings (str): Text\nIntegers (int): Integer value\nFloats (float): Real value\nBooleans (bool): True or False\n\nBecause Python is dynamically typed, there is no need to explicitly mention the type of the variable. Yet, in some cases, it may be important to cast variables from one type to another.\nMore on this in the next lecture."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#control-structures",
    "href": "lectures/lecture_01/introduction_to_python.html#control-structures",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.2 Control structures",
    "text": "3.2 Control structures\nControl structures allow to condition the sequence of action of a code on the particular value a variable exhibits at the time of execution.\n\nConditional statements\nLoops\n\nNote: tabs are organizational pillars of the Python code structure\n\n3.2.1 Conditional statements\nConditional statements consider the specific value of a variable at the time of execution and determine the outcome based on a logical operation.\nStructure\n    If CONDITON HOLDS:\n        OUTCOME 1\n    Elif OTHER CONDITION HOLDS:\n        OUTCOME 2\n    Else:\n        OUTCOME 3\nNote: check the tabs\n\nbalance = 5000\nif balance &gt;= 10000:\n    print(\"You are eligible for premium services.\")\nelse:\n    print(\"Standard services apply.\")\n\n\n\n3.2.2 Loops\nLoops repeat a sequence of actions until a condition is satisfied. There are two types of loops:\n\nwhile\nfor\n\n\nWhile\nStructure\n    While CONDITION HOLDS:\n        ACTION(s)\n\n# Use case: Simulating monthly deposit growth\nbalance = 1000\nmonths = 0\nwhile balance &lt; 2000:\n    balance += 100  # Monthly deposit\n    months += 1\nprint(f\"It took {months} months to double the balance.\")\n\n\n\nFor\nStructure\n    For CONDITION HOLDS | Increment action:\n        ACTION(s)\n\n# Use case: Summing up daily returns from a list\ndaily_returns = [0.01, -0.02, 0.03, 0.02, -0.01]\ntotal_return = 0\nfor r in daily_returns:\n    total_return += r\nprint(\"Total return for the week:\", total_return)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#functions",
    "href": "lectures/lecture_01/introduction_to_python.html#functions",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.3 Functions",
    "text": "3.3 Functions\nA function is a reusable block of code that is saved up and can be called at multiple places in the main script.\nStructure\n    def my_function (parameters):\n        ACTION(s)\n        return VALUE\n\n# Function to calculate compound interest\ndef calculate_compound_interest(principal, rate, time):\n    return principal * (1 + rate) ** time\n\n\n# Example usage\nresult = calculate_compound_interest(1000, 0.05, 5)\nprint(\"Compound Interest:\", result)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#data-structures",
    "href": "lectures/lecture_01/introduction_to_python.html#data-structures",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.4 Data structures",
    "text": "3.4 Data structures\n\n3.4.1 Lists\nLists allow to store and treat mutliple data points into one variable\n\n# Example: List of daily stock prices\nstock_prices = [150.25, 153.50, 152.00, 155.00]\nprint(stock_prices[0])  # Accessing the first day's price\nstock_prices.append(157.25)  # Adding a new day's price\nprint(stock_prices)\n\n\n\n3.4.2 Dictionaries\nDictionnaries allow store and treat multiple pairs of data point associating keys and values.\n\n# Example: Dictionary to store portfolio allocation\nportfolio = {\n    \"AAPL\": 5000,\n    \"GOOGL\": 3000,\n    \"AMZN\": 2000\n}\nprint(portfolio[\"AAPL\"])  # Accessing allocation for AAPL\nportfolio[\"GOOGL\"] += 1000  # Updating allocation for GOOGL\nprint(portfolio)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#libraries",
    "href": "lectures/lecture_01/introduction_to_python.html#libraries",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.5 Libraries",
    "text": "3.5 Libraries\nLibraries are pre-built packages of functions for tasks like data analysis and visualization.\n\nKey Libraries for Finance\n\nNumPy: For numerical computations matrix operations in portfolio analysis\npandas: Used for data manipulation handling financial datasets\nmatplotlib: For data visualization plotting stock prices\n\n\nimport numpy \n\nprint(numpy.sqrt(16))  # Square root\nprint(numpy.pi)        # Value of pi\n\n\n\nDocumentation\nLibraries come with documentation.\nOn Notebooks, they can be directly accessed from the cell pressing maj + tab after the function.\n\nExample of documentation numpy.sqrt()\n    Call signature:  numpy.sqrt(*args, **kwargs)\nType:            ufunc\nString form:     &lt;ufunc 'sqrt'&gt;\nFile:            ~/opt/anaconda3/lib/python3.9/site-packages/numpy/__init__.py\nDocstring:      \nsqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.\n\nParameters\n----------\nx : array_like\n    The values whose square-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlib.scimath.sqrt\n    A version which returns complex numbers when given negative reals.\n\nNotes\n-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\n\nExamples\n--------\n&gt;&gt;&gt; np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n&gt;&gt;&gt; np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n&gt;&gt;&gt; np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])\nClass docstring:\nFunctions that operate element by element on whole arrays.\n\nTo see the documentation for a specific ufunc, use `info`.  For\nexample, ``np.info(np.sin)``.  Because ufuncs are written in C\n(for speed) and linked into Python with NumPy's ufunc facility,\nPython's help() function finds this page whenever help() is called\non a ufunc.\n\nA detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.\n\n**Calling ufuncs:** ``op(*x[, out], where=True, **kwargs)``\n\nApply `op` to the arguments `*x` elementwise, broadcasting the arguments.\n\nThe broadcasting rules are:\n\n* Dimensions of length 1 may be prepended to either array.\n* Arrays may be repeated along dimensions of length 1.\n\nParameters\n----------\n*x : array_like\n    Input arrays.\nout : ndarray, None, or tuple of ndarray and None, optional\n    Alternate array object(s) in which to put the result; if provided, it\n    must have a shape that the inputs broadcast to. A tuple of arrays\n    (possible only as a keyword argument) must have length equal to the\n    number of outputs; use None for uninitialized outputs to be\n    allocated by the ufunc.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.\n\nReturns\n-------\nr : ndarray or tuple of ndarray\n    `r` will have the shape that the arrays in `x` broadcast to; if `out` is\n    provided, it will be returned. If not, `r` will be allocated and\n    may contain uninitialized values. If the function has more than one\n    output, then the result will be a tuple of arrays."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science For Finance",
    "section": "",
    "text": "This website accompanies the course of Data Science For Finance (B-KUL-HMA99A)."
  },
  {
    "objectID": "index.html#news-announcements",
    "href": "index.html#news-announcements",
    "title": "Data Science For Finance",
    "section": "News & Announcements",
    "text": "News & Announcements\n\n07/10/2025\n\nRecordings for Lecture 03 and 04 are available\nSolutions to Problem set of Lecture 02 are available\nNew: A beta test All Day TA is available for the course.\n\nAll Day TA is an interactive AI tutor trained on the course material and synced with the course schedule for learning support.\n\n\n01/10/2025\n\nRecordings for Introduction, and Lecture 01 and 02 are available\nSolutions to Problem set of Lecture 02 will be available next week\n\n25/09/2025\n\nThe course is live\nMaterial for Lecture 01 and 02 is available"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Course Information",
    "section": "",
    "text": "Professor: Tarik Roukny (tarik.roukny@kuleuven.be)\nLectures: Wednesdays\n\nTime blocks for sessions\n\n08.30 AM - 10.30 AM\n10.30 PM - 12.30 PM\n\nRoom HER1 - 04.4207\n\nOffice hours: by email appointment."
  },
  {
    "objectID": "syllabus.html#prerequisites",
    "href": "syllabus.html#prerequisites",
    "title": "Course Information",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis is a beginner’s course for programming: no prior computer skills are required\n\nKnowledge of statistics and basic econometrics is required\nKnowledge of Financial Markets and Institutions and Corporate Finance is advised"
  },
  {
    "objectID": "syllabus.html#content",
    "href": "syllabus.html#content",
    "title": "Course Information",
    "section": "Content",
    "text": "Content\n\nIntroduction to Scientific Programming\n\nProgramming Environment\nNotebooks\nBasics of Python Programming Language\n\nData Manipulation\n\nData Analytics\nData Treatment\nData Visualization\n\nApplying Data Science in Finance\n\nTime series\nNetwork Analysis\nMachine Learning"
  },
  {
    "objectID": "syllabus.html#delivery",
    "href": "syllabus.html#delivery",
    "title": "Course Information",
    "section": "Delivery",
    "text": "Delivery\nMaterial is delivered through Jupyter Notebooks. The presentation format of files is ‘.ipynb’ and can be read from the Jupyter interface or other services. Notebooks are interactive and can be used off-the-shell to run code. Static and printable version in pdf and HTML of the material are also available."
  },
  {
    "objectID": "syllabus.html#reference",
    "href": "syllabus.html#reference",
    "title": "Course Information",
    "section": "Reference",
    "text": "Reference\nPython for Finance, 2nd Edition by Yves Hilpisch"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html",
    "href": "lectures/lecture_01/lecture_01.html",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html#lecture-material",
    "href": "lectures/lecture_01/lecture_01.html#lecture-material",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html#recording",
    "href": "lectures/lecture_01/lecture_01.html#recording",
    "title": "Lecture 01 - Introduction to Python",
    "section": "Recording",
    "text": "Recording\n\n1. Motivation\n\n \n\n\n\n2. Setting up the environment\n\n \n\n\n\n3. Overview of the Python environment"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html",
    "href": "lectures/lecture_02/data_types_and_structure.html",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "",
    "text": "In Python, types and structures are fundamental concepts that allow the storage, manipulation, and organization of data.\nThis notebook covers:\n\nBasic data types: int, float, bool, str\nData structures: tuple, list, set, dict\nOperations and built-in methods"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#overview",
    "href": "lectures/lecture_02/data_types_and_structure.html#overview",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "",
    "text": "In Python, types and structures are fundamental concepts that allow the storage, manipulation, and organization of data.\nThis notebook covers:\n\nBasic data types: int, float, bool, str\nData structures: tuple, list, set, dict\nOperations and built-in methods"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#basic-types",
    "href": "lectures/lecture_02/data_types_and_structure.html#basic-types",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "1. Basic Types",
    "text": "1. Basic Types\nList of types\n\n\n\nObject type\nMeaning\nUsed for\n\n\n\n\nint\ninteger value\nnatural numbers\n\n\nfloat\nfloating-point number\nreal numbers\n\n\nbool\nboolean value\ntrue or false\n\n\nstr\nstring object\ncharacter, word, text\n\n\n\nuse built-in function type() to obtain the information\n\n1.1 Integers and Floats\nIntegers are whole numbers, while floats are numbers with decimal values.\n\nInt\n\na = 10\ntype(a)\n\nArithmetic operations: + - * /\n\n1 + 4 \n\n\na + 1\n\n\ntype(1+4)\n\n\n\nFloats\n\ntype (1/4)\n\n\n1/4\n\n\ntype(0.25)\n\n\ntype (0)\n\n\ntype (0.0)\n\n\n# Example: Representing account balances\nbalance = 1000  # Integer\ninterest_rate = 5.5  # Float\n\n\n# Calculating interest\ninterest = balance * interest_rate / 100\nprint(\"Interest:\", interest)\n\n\n\n\n1.2 Booleans\nBooleans represent True or False values.\n\n# Example: Checking if an account is active\naccount_active = True\nif account_active == True:\n    print(\"The account is active.\")\nelse:\n    print(\"The account is inactive.\")\n\n\n# implicit comparison\nif account_active:\n    print(\"The account is active.\")\nelse:\n    print(\"The account is inactive.\")\n\n\nConditions: &gt; &lt; &gt;= &lt;= == !=\n\n4 &gt; 3\n\n\ntype (4 &gt; 3)\n\n\ntype (False)\n\n\n4 &gt;= 3\n\n\n4 &lt; 3\n\n\n4 == 3\n\n\n4 != 3\n\n\n\nLogic operations: and or not in\n\nTrue and True\n\n\nFalse and False\n\n\nTrue or True\n\n\nTrue or False\n\n\nFalse or False\n\n\nnot True\n\n\nnot False\n\n\n\nCombinations\n\n(4 &gt; 3) and (2 &gt; 3)\n\n\n(4==3) or (2 != 3)\n\n\nnot (4 != 4)\n\n\n(not (4 != 4)) and (2 == 3)\n\nNote: Major for control condition (if while for) – see later\n\nif 4 &gt; 3:\n    print ('condition true')\nelse:\n    print ('condition not true')\n\n\ni = 0\nwhile i &lt; 4:\n    print ('condition true: i = ', i)\n    i = i + 1\n\n\n\nBoolean casting: 0,1 (and other values)\n\nint(True)\n\n\nint(False)\n\n\nfloat(True)\n\n\nfloat(False)\n\n\nbool(0)\n\n\nbool(1)\n\n\nbool(0.0)\n\n\nbool(1.0)\n\n\nbool(10.5)\n\n\nbool(-2)\n\n\n\n\n1.3 Strings\nStrings are used to represent text.\n\n# Example: Representing account holder information\naccount_holder = \"John Doe\"\naccount_number = \"1234567890\"\n\nprint(\"Account Holder:\", account_holder)\nprint(\"Account Number:\", account_number)\n\n\ntype(account_holder)\n\n\nBuilt-in methods\nstr variables come with a series of useful built-in methods.\n\n\n\nMethod\n\n\n\n\ncapitalize()\n\n\ncount()\n\n\nfind()\n\n\njoin()\n\n\nreplace()\n\n\nsplit()\n\n\nupper()\n\n\n\n\nt = 'this is a string object'\n\n\nt.capitalize()\n\n\nt.split('i')\n\n\nt.find('string')\n\n\nt.replace(' ','|')\n\n\n\nPrint method print()\n\nprint('Hello World!')\n\n\nprint (t)\n\n\ni = 0\nwhile i &lt; 4:\n    print (i)\n    i = i + 1\n\n\ni = 0\nwhile i &lt; 4:\n    print (i, end = '|')\n    i = i + 1\n\n\n\nPrinting with variables\n\na = 10\nprint('this is the value of a:', a)\n\n\ntt = 'this is the value of a: ' + str(a)\nprint (tt)"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#basic-structures",
    "href": "lectures/lecture_02/data_types_and_structure.html#basic-structures",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "2. Basic structures",
    "text": "2. Basic structures\nList of structures\n\n\n\nObject type\nMeaning\nUsed for\n\n\n\n\ntuple\nimmutable container\nfixed set of objects\n\n\nlist\nmutable container\nordered and changing set of objects\n\n\ndict\nmutable container\nkey-value store\n\n\nset\nmutable container\nunordered collection of unique objects\n\n\n\nuse built-in function type() to obtain the information\nNavigating structures\n\nIndexing: obtain item at position n s[n]\nSlicing: obtain items between position i and j s[i:j] s[i:] s[:j]\nRanging: obtain items between position i and j spaced by k s[i:j:k]\n\nNote: In Python, indexing starts at 0\n\n2.1 tuple\nTuples are immutable collections of items (i.e., cannot be changed after creation).\n\n# Example: Coordinates of a bank branch\nbranch_location = (40.7128, -74.0060)  # New York City coordinates\nprint(\"Branch Location:\", branch_location)\n\n\nt = (1, 2.5, 'data')\ntype(t)\n\n\n#also works without ()\nt = 1, 2.5, 'data'\ntype(t)\n\n\n#indexing\nt[2]\n\n\ntype(t[2])\n\n\n\n2.2 list\nLists are ordered collections of items, which can be of mixed data types.\n\n# Example: List of recent transactions\ntransactions = [100, -50, 200, -30, 400]\nprint(\"Transactions:\", transactions)\n\n# Adding a new transaction\ntransactions.append(-100)\nprint(\"Updated Transactions:\", transactions)\n\n\nl = [1, 2.5, 'data']\nl[2]\n\n\n#casting\nl = list(t)\nl\n\n\ntype (l)\n\n\nBuilt-in methods\n\n\n\nMethod\n\n\n\n\nl[i] = x\n\n\nl[i:j:k] = s\n\n\nappend()\n\n\ncount()\n\n\ndel l[i:j:k]\n\n\nindex()\n\n\nextend()\n\n\ninsert()\n\n\nremove()\n\n\npop()\n\n\nrevers()\n\n\nsort()\n\n\n\ncontrary to tuples, lists are mutable containers\n\nl.append([4,3])\nl\n\n\nl.extend([1.0, 1.5, 2.0])\nl\n\n\nl = [0, 1, 2, 3, 4, 5, 6, 7]\ns = [10, 20, 30]\n\nl[1:7:2] = s\nprint(l)\n\n\nl.insert(1,'insert')\nl\n\n\nl.remove('data')\nl\n\n\np = l.pop(3)\nprint (l, p)\n\n\n#slicing\nl[2:5]\n\nMutable vs immutable objects\n\nt = (1, [2, 3], 4)\n\n\nt[1].append(5)    \n\n\nprint(t)          \n\n\nt[0] = 9\n\n\n\n\n2.3 dict\nDictionaries store data as key-value pairs.\n\n# Example: Dictionary of account balances\naccount_balances = {\n    \"1234567890\": 1000,\n    \"0987654321\": 2500,\n    \"1122334455\": 750\n}\nprint(\"Account Balances:\", account_balances)\n\n# Accessing a balance by account number\nprint(\"Balance of account 1234567890:\", account_balances[\"1234567890\"])\n\n\nKeys and values\n\nd = {\n    'Name' : 'Iron Man',\n    'Country' : 'USA',\n    'Profession' : 'Super Hero',\n    'Age' : 36\n}\n\n\ntype(d)\n\n\nprint (d['Name'], d['Age'])\n\n\n\nBuilt-in methods\n\n\n\nMethod\n\n\n\n\nd[k]\n\n\nd[k] = x\n\n\ndel d[k]\n\n\nclear()\n\n\ncopy()\n\n\nitems()\n\n\nkeys()\n\n\nvalues()\n\n\npopitem()\n\n\nupdate()\n\n\n\n\nd.keys()\n\n\nd.values()\n\n\nd.items()\n\n\nbirthday = True\nif birthday:\n    d['Age'] += 1\nprint (d['Age'])\n\n\nfor item in d.items():\n    print (item)\n\n\nfor value in d.values():\n    print (type(value))\n\n\n\n\n2.4 set\nSets are unordered collections of unique items.\n\ns = set(['u', 'd', 'ud', 'du', 'd', 'du'])\ns\n\n\nSet operations\n\nt = set(['d', 'dd', 'uu', 'u'])\n\n\ns.union(t)\n\n\ns.intersection(t)\n\n\ns.difference(t)\n\n\nt.difference(s)\n\n\ns.symmetric_difference(t)"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02_problem_sets.html",
    "href": "lectures/lecture_02/lecture_02_problem_sets.html",
    "title": "Data Types and Structures - Problem sets",
    "section": "",
    "text": "Exercise 1: Check Data Types\nWrite a Python program that prints the data types of the following variables:\na = 42\nb = 3.14\nc = \"Python\"\nd = [1, 2, 3]\ne = (1, 2, 3)\nf = {'name': 'John', 'age': 30}\ng = {1, 2, 3}\n\n# Your code\n\n\n\nExercise 2: List Operations\nCreate a list with the elements [10, 20, 30, 40, 50]. Add 60 to the list, remove 30, and reverse the list.\n\n# Your code\n\n\n\nExercise 3: Tuple Unpacking\nGiven the following tuple, unpack its elements into separate variables and print them:\nmy_tuple = (100, 200, 300)\n\n# Your code\n\n\n\nExercise 4: Dictionary Manipulation\nCreate a dictionary with keys 'name', 'age', and 'city', and values 'Alice', 25, and 'New York'. Update the age to 26 and add a new key 'profession' with value 'Engineer'.\n\n# Your code\n\n\n\nExercise 5: Set Operations\nCreate two sets, set1 with elements {1, 2, 3, 4} and set2 with elements {3, 4, 5, 6}. Find the union, intersection, and difference between these sets.\n\n# Your code\n\n\n\nExercise 6: String Slicing\nGiven the string s = \"Hello, Python!\", write code to: 1. Extract the substring \"Python\". 2. Reverse the entire string.\n\n# Your code\n\n\n\nExercise 7: Boolean Logic\nYou are given three numbers, a, b, and c. Write a Python program that returns True if a is the largest number and b is not equal to c. Otherwise, return False.\n\n# Input numbers\na = 10\nb = 5\nc = 5\n\n# Your code\n\n\n\nExercise 8: Complex Boolean Logic with Multiple Conditions\nWrite a Python program that checks the following conditions for three variables x, y, and z:\n\nx is greater than y or y is equal to z.\nThe sum of x and y is even.\nx, y, and z are all positive numbers.\n\nThe program should return True only if all three conditions are met.\n\n# Input variables\nx = 8\ny = 6\nz = 6\n\n# Your code\n\n\n\nExercise 9: Checking for Keys in a Dictionary\nGiven the dictionary person = {'name': 'Bob', 'age': 25}, check if the key 'age' exists in the dictionary and print a message.\n\n# Your code\n\n\n\nExercise 10: Nested Data Structures\nCreate a dictionary students where each key is a student’s name and each value is a dictionary containing their 'age' and a list of their 'grades'.\nEnter the following data in the dictionary: - Alice is 24 and has grades 88, 92 and 86 - Bob is 23 and had grades 75, 80, 89\nPrint Bob’s age and Alice’s grades.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_04/functions.html",
    "href": "lectures/lecture_04/functions.html",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Functions are a key concept in programming that allow to reuse code, make programs more modular, and simplify complex tasks.\nIn Python, functions are defined using the def keyword.\nThis notebook covers: - Definition and calls - Parameters and arguments - Return values - Scope of variables - Built-in vs. user-defined functions - Functional and anonymous programming"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#overview",
    "href": "lectures/lecture_04/functions.html#overview",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Functions are a key concept in programming that allow to reuse code, make programs more modular, and simplify complex tasks.\nIn Python, functions are defined using the def keyword.\nThis notebook covers: - Definition and calls - Parameters and arguments - Return values - Scope of variables - Built-in vs. user-defined functions - Functional and anonymous programming"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#basics-of-functions",
    "href": "lectures/lecture_04/functions.html#basics-of-functions",
    "title": "Lecture 04 - Functions",
    "section": "1. Basics of Functions",
    "text": "1. Basics of Functions\n\n1.1 Definition and calls\nIn Python, a function is defined using the def keyword followed by the function name and parentheses ().\nOnce implemented, the function is called using the name and parantheses.\nAs long as the function is not called, nothing happens (no output).\n\n# Example of a simple function\ndef greet_bank_customer():\n    print(\"Welcome to ABC Bank!\")\n\n\n# Call the function\ngreet_bank_customer()\n\n\n\n1.2 Arguments\nFunctions can accept inputs, known as arguments or parameters, which are passed into the function using the parentheses.\n\n# Function to calculate simple interest\ndef calculate_simple_interest(principal, rate, time):\n    interest = principal * rate * time / 100\n    print(f\"The interest is: {interest}\")\n\n\n# Call the function with arguments\ncalculate_simple_interest(1000, 5, 2)  # Principal = 1000, Rate = 5%, Time = 2 years\n\n\n\n1.3 Return Values\nFunctions can return a value which can be assigned to an external variable. This obtains from the return statement.\n\n# Function to calculate and return compound interest\ndef calculate_compound_interest(principal, rate, time):\n    amount = principal * (1 + rate/100)**time\n    interest = amount - principal\n    return interest\n\n\n# Call the function and store the result\ncompound_interest = calculate_compound_interest(1000, 5, 2)\nprint(\"The compound interest is:\", compound_interest)\n\n\n\n1.4 Variable Scope\nVariables defined inside a function are local to that function and cannot be accessed outside of it.\nThis is called the scope of a variable.\n\ndef calculate_balance():\n    balance = 5000  # Local variable\n    print(\"Balance inside the function:\", balance)\n\n\ncalculate_balance()\n\n\nprint(balance)  # This will raise an error because balance is not accessible outside the function\n\n\n\n1.5 Built-in vs. User-defined Functions\nPython provides many built-in functions like print(), len(), sum(), etc.\nUser-defined functions can also be used to extend and improve such functions.\n\ntransactions = [100, -50, 200, -100]\ntotal = sum(transactions)\nprint(\"Total balance after transactions:\", total)\n\n\ndef calculate_npv(cash_flows, discount_rate):\n    npv = sum(cf / (1 + discount_rate) ** t for t, cf in enumerate(cash_flows, 1))\n    return npv\n\ncash_flows = [-1000, 200, 300, 400, 500]\nprint(\"Net Present Value:\", calculate_npv(cash_flows, 0.05))"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#functional-programming",
    "href": "lectures/lecture_04/functions.html#functional-programming",
    "title": "Lecture 04 - Functions",
    "section": "2. Functional programming",
    "text": "2. Functional programming\nFunctional programming is a style of programming that treats computation as the evaluation of functions, just like in mathematics.\n\nData is kept unchanged rather than modified\n\nFunctions are written as pure functions: the same input always produces the same output, with no hidden effects\n\nHigher-order functions: can be passed to other functions or returned as results\n\nPython supports functional programming features, making it easy to apply functional programming techniques.\n\ngood practice: Avoiding loops as much as possible and making full use of list comprehensions and functional programming techniques.\n\n\nMath vs. Python Example\nMathematics:\n\\[\nf(x) = x^2\n\\]\n\nInput \\(2 \\rightarrow 4\\)\nInput \\(3 \\rightarrow 9\\)\n\nPython:\ndef f(x):\n    return x**2\n\nf(2)  # 4\nf(3)  # 9\n\n\n2.1 Pure function\nA pure function is a function that: - Always produces the same output given the same input. - Has no side effects (e.g., modifying external variables, changing mutable data, etc.).\nExample of a Pure Function:\n\ndef add(a, b):\n    return a + b\n\nThis function always returns the sum of a and b without modifying anything outside the function.\nNon-Pure Function (with side effects):\n\ntotal = 0\n\ndef add_to_total(amount):\n    global total\n    total += amount\n    return total\n\nThis function modifies the global variable total, which is considered a side effect and makes it a non-pure function.\n\n\n2.2 Higher-order function\nA higher-order function is a function that takes one or more functions as arguments or returns a function as its result.\nExample of a Higher-Order Function:\n\ndef apply_twice(func, value):\n    return func(func(value))\n\ndef double(x):\n    return x * 2\n\nprint(apply_twice(double, 5))\n\n\n\n2.3 Anonymous Functions (lambda)\nIn Python, lambda functions are anonymous functions that can have any number of arguments but only one expression.\nLambdas are useful for short functions without explicit definitions.\nLambda Function Syntax:\nlambda arguments: expression\n\nadd = lambda a, b: a + b\nprint(add(3, 4))  # Output: 7\n\n\n# Lambda function for multiplication\nmultiply = lambda x, y: x * y\nprint(multiply(4, 2))  # Output: 8\n\n\n# Lambda function with if-else to check if a number is even or odd\neven_or_odd = lambda x: 'even' if x % 2 == 0 else 'odd'\nprint(even_or_odd(4))  # Output: even\nprint(even_or_odd(7))  # Output: odd\n\n\n# Convert a string to uppercase using lambda\nto_upper = lambda s: s.upper()\nprint(to_upper('hello'))  # Output: HELLO\n\n\n# Lambda function to calculate the maximum of three numbers\nmax_of_three = lambda a, b, c: a if (a &gt; b and a &gt; c) else (b if b &gt; c else c)\nprint(max_of_three(10, 20, 15))  # Output: 20\n\n\n\n2.4 Functional Programming Tools in Python\nPython provides several built-in functions that are useful in functional programming\n\nmap()\nApplies a given function to each item of an iterable (like a list) and returns a map object.\n\nnumbers = [1, 2, 3, 4, 5]\nsquared_map = map(lambda x: x ** 2, numbers)\nsquared = list(squared_map)\nprint(squared)  \nprint (squared_map)\n\n\n\nfilter()\nFilters items in an iterable based on a given function and returns an iterator.\n\nnumbers = [1, 2, 3, 4, 5, 6]\nevens_iterator = filter(lambda x: x % 2 == 0, numbers)\nevens = list(evens_iterator)\nprint(evens) \nprint(evens_iterator)\n\nNote: iterators in Python are exhausted after one use. Once converted to a list using list(evens_iterator), the iterator is consumed and cannot be used again.\n\n\nreduce()\nPerforms a rolling computation to sequential pairs of values in a list. It requires importing from the functools module.\n\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4]\nresult = reduce(lambda a, b: a * b, numbers)\n# Step 1: 1 * 2 = 2\n# Step 2: 2 * 3 = 6\n# Step 3: 6 * 4 = 24\nprint(result)  \n\n\n\nzip()\nCombines two or more iterables into a single iterable of tuples.\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 90, 95]\n\nzipped = list(zip(names, scores))\nprint(zipped)\n\n\n\nsorted()\nLambda functions can be used to define custom sorting behavior when using sorted().\n\n# Sort a list of tuples based on the second element (using lambda)\npairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\nsorted_pairs = sorted(pairs, key=lambda pair: pair[1])\nprint(sorted_pairs)\n\n\n\nList Comprehension\nAlthough list comprehension is not purely functional, it is closely aligned with functional programming ideas as it allows to create new lists in a concise way.\n\nsquares = [x ** 2 for x in range(5)]\nprint(squares)  # Output: [0, 1, 4, 9, 16]\n\n\n\nDictionaries\nLambda functions can be used to get custom behavior when working with dictionaries, like finding the maximum or minimum key.\n\n# Find the key with the highest value in a dictionary\nscores = {'Alice': 85, 'Bob': 90, 'Charlie': 88}\nhighest_scorer = max(scores, key=lambda k: scores[k])\nprint(highest_scorer)  # Output: Bob\n\nNote: max() and dict:\n1.max(scores): Finds the maximum key (default behavior).\n2.max(scores.values()): Finds the maximum value.\n3.max(scores, key=lambda k: scores[k]): Finds the key corresponding to the maximum value."
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html",
    "href": "lectures/lecture_03/lecture_03.html",
    "title": "Lecture 03 - Control structures",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#lecture-material",
    "href": "lectures/lecture_03/lecture_03.html#lecture-material",
    "title": "Lecture 03 - Control structures",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#recording",
    "href": "lectures/lecture_03/lecture_03.html#recording",
    "title": "Lecture 03 - Control structures",
    "section": "Recording",
    "text": "Recording\n\n1. Intro\n\n \n\n\n\n2. If\n\n \n\n\n\n3. while\n\n \n\n\n\n4. for"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#problem-sets",
    "href": "lectures/lecture_03/lecture_03.html#problem-sets",
    "title": "Lecture 03 - Control structures",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html",
    "href": "lectures/lecture_03/control_structures.html",
    "title": "Lecture 03 - Control Structures",
    "section": "",
    "text": "Control structures are essential in programming: they allow to control the flow of the code.\nIn Python, the primary control structures are if, while, and for loops. These structures are crucial in decision-making processes and repetitive tasks.\nThis notebook covers: - if statements - while loops for repeated execution based on a condition - for loops for iterating over sequences - Counter-based loops - List comprehension"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#overview",
    "href": "lectures/lecture_03/control_structures.html#overview",
    "title": "Lecture 03 - Control Structures",
    "section": "",
    "text": "Control structures are essential in programming: they allow to control the flow of the code.\nIn Python, the primary control structures are if, while, and for loops. These structures are crucial in decision-making processes and repetitive tasks.\nThis notebook covers: - if statements - while loops for repeated execution based on a condition - for loops for iterating over sequences - Counter-based loops - List comprehension"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-if-statement",
    "href": "lectures/lecture_03/control_structures.html#the-if-statement",
    "title": "Lecture 03 - Control Structures",
    "section": "1. The if Statement",
    "text": "1. The if Statement\nThe if statement executes a block of code only if a certain condition is True.\nSuch conditional statements consider the specific value of a variable at the time of execution and determine the outcome based on a logical operation.\n\nStructure\n    If CONDITON HOLDS:\n        OUTCOME 1\n    Elif OTHER CONDITION HOLDS:\n        OUTCOME 2\n    Else:\n        OUTCOME 3\nNote: check the tabs\n\n# Example: withdrawal\nbalance = 500\nwithdrawal_amount = 800\n\nif balance &gt;= withdrawal_amount:\n    balance -= withdrawal_amount\n    print(f\"Withdrawal successful! New balance: {balance}\")\nelse:\n    print(\"Insufficient funds.\")   \n\n\n# Input values\nsavings = float(input(\"Enter your savings amount in dollars: \"))\nmonthly_income = float(input(\"Enter your monthly income in dollars: \"))\ndebt = float(input(\"Enter your debt amount in dollars: \"))\n\n# Applying the conditions using if, elif, and else statements\nif savings &gt; 50000 and debt == 0:\n    print(\"You should invest in stocks.\")\nelif debt &gt; 0 and savings &gt; 20000 and monthly_income &gt; 4000:\n    print(\"You should pay off debt aggressively.\")\nelif savings &lt; 20000 and debt &gt; 10000:\n    print(\"You should save more and minimize spending.\")\nelse:\n    print(\"You should create a budget and build an emergency fund.\")"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-while-loop",
    "href": "lectures/lecture_03/control_structures.html#the-while-loop",
    "title": "Lecture 03 - Control Structures",
    "section": "2. The while Loop",
    "text": "2. The while Loop\nThe while loop repeats a block of code as long as a specified condition is true.\n\n2.1 Structure\n    While CONDITION HOLDS:\n        ACTION(s)\n\n# Example: Simulating a simple ATM withdrawal process\nbalance = 1000\nwithdrawal_attempts = 0\nwithdrawal_amount = 200\n\nwhile balance &gt; 0 and withdrawal_attempts &lt; 3:\n    if balance &gt;= withdrawal_amount:\n        balance -= withdrawal_amount\n        print(f\"Withdrawal successful! New balance: {balance}\")\n    else:\n        print(\"Insufficient funds.\")\n    withdrawal_attempts += 1\n\n\n\n2.2 When using a while loop:\n\nLoop Condition and Termination: Ensure the loop has a valid exit condition that will eventually become False.\n\n\ncount = 0\nwhile count &lt; 5:  # Loop will terminate when count reaches 5\n    print(f\"Count is {count}\")\n    count += 1\n\nIf the loop condition (e.g., count &lt; 5) is never met, the loop will not stop naturally.\n\nUpdate Loop Variable: Ensure the variable controlling the loop is updated to prevent infinite loops.|\n\n\nbalance = 1000\nmonthly_payment = 200\n\nwhile balance &gt; 0:\n    balance -= monthly_payment  # Update balance each iteration\n    print(f\"Remaining balance: ${balance}\")\n\n\nThe balance is reduced each time until it reaches zero, terminating the loop.\n\n\nBreak and Exit Conditions: Use break to exit early when certain conditions are met.\n\n\nwhile True:\n    user_input = input(\"Type 'exit' to stop: \")\n    if user_input == 'exit':\n        print(\"Exiting the loop.\")\n        break\n\n\nThe loop terminates immediately when the user types 'exit'.\n\n\nEfficiency and Performance: Avoid heavy computations inside the loop to maintain performance.\n\n\nn = 1000000\ni = 0\nwhile i &lt; n:\n    i += 1  # Efficient loop, only counting\n# Avoid putting expensive operations here\nprint(f\"Loop completed {n} iterations.\")\n\n\nThe loop is efficient and avoids unnecessary complex calculations inside.\n\n\nEdge Case Handling: Plan for edge cases by adding safety conditions, such as a maximum number of iterations.\n\n\nloan_balance = 5000\nmonthly_payment = 300\nmax_months = 60  # Safety condition to prevent infinite loop\nmonths = 0\n\nwhile loan_balance &gt; 0 and months &lt; max_months:\n    loan_balance -= monthly_payment\n    months += 1\n    if loan_balance &lt; 0:\n        loan_balance = 0\n        break\n\nprint(f\"Loan repaid in {months} months.\")\n\n\nThe loop stops if either the loan is repaid or the maximum number of months is reached.\n\n\n\n2.3 Full example: Loan Repayment Simulation\nSet-up: A user takes out a loan of \\(\\$ 100,000\\) with an annual interest rate of 5%. The user makes fixed monthly payments of \\(\\$ 1,500\\).\nGoal:\n\nCalculate how many months it will take to pay off the loan.\nTrack how much total interest is paid by the time the loan is fully repaid.\n\nTo consider: In this example, we simulate the process of repaying a loan with monthly payments.\nThe goal is to calculate how long it will take to fully repay the loan, considering:\n\nA principal loan amount.\nA fixed monthly payment.\nA monthly interest rate (compound interest).\n\nWe use a while loop to simulate the monthly loan repayment process until the loan is fully repaid. The loop keeps running as long as the loan balance is greater than zero.\n\n# Loan parameters\nprincipal = 100000  # Initial loan amount in dollars\nannual_interest_rate = 0.05  # 5% annual interest\nmonthly_payment = 1500  # Monthly payment in dollars\n\n\n# Calculated monthly interest rate\nmonthly_interest_rate = annual_interest_rate / 12\n\n\n# Initialize variables\nloan_balance = principal  # Remaining loan balance starts as the principal\ntotal_interest_paid = 0  # Track the total interest paid\nmonths = 0  # Track the number of months needed to repay the loan\n\n\n# Loop until the loan is repaid\nwhile loan_balance &gt; 0:\n    # Calculate interest for the current month\n    monthly_interest = loan_balance * monthly_interest_rate\n    total_interest_paid += monthly_interest\n\n    # Update loan balance by subtracting the monthly payment (minus the interest portion)\n    loan_balance = loan_balance + monthly_interest - monthly_payment\n\n    # Increment the number of months\n    months += 1\n\n    # If the loan balance becomes less than the monthly payment in the final month,\n    # pay off the remaining balance and break the loop\n    if loan_balance &lt; monthly_payment:\n        total_interest_paid += loan_balance * monthly_interest_rate  # Final month's interest\n        loan_balance = 0  # Set the balance to 0\n        months += 1  # Add the final month\n\n\n# Output the result\nprint(f\"It will take {months} months to repay the loan.\")\nprint(f\"Total interest paid over the life of the loan: ${total_interest_paid:.2f}\")"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-for-loop",
    "href": "lectures/lecture_03/control_structures.html#the-for-loop",
    "title": "Lecture 03 - Control Structures",
    "section": "3. The for Loop",
    "text": "3. The for Loop\nThe for loop is used to iterate over a sequence (like a list, tuple, string, etc.) and execute a block of code for each item in the sequence.\n\n3.1 Structure\n    For ITEM in ITERABLE:\n        ACTION(s)\n\nitem: This is a variable that takes the value of each element in the sequence on every iteration.\niterable: This is any Python object that can return one item at a time, like lists, tuples, strings, ranges, etc.\n\nHow It Works\n\nThe for loop goes through each item in the iterable one by one.\nOn each iteration, the item variable is assigned the next value in the sequence, and the block of code inside the loop is executed.\nThis continues until all items in the iterable have been processed.\n\n\nfruits = ['apple', 'banana', 'cherry']\n\nfor fruit in fruits:\n    print(fruit)\n\n\n\n3.2 Looping over lists, dictionnaries and strings\n\nl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfor element in l[2:5]:\n    print (element ** 2)\n\n\nd = {\n    \"program\": \"Master of Business Administration\",\n    \"year\": 2025,\n    \"number_of_students\": 42,\n    \"average_age\": 22,\n    \"specializations\": [\"Finance\", \"Marketing\", \"Data Science\", \"Strategy\"]\n}\nfor item in d.items():\n    print (item)\n\n\nfor value in d.values():\n    print (type(value))\n\n\n# Example: Calculating the total balance from a list of transactions\ntransactions = [100, -50, 200, -75, 150]\ntotal_balance = 0\n\nfor transaction in transactions:\n    total_balance += transaction\n\nprint(\"Total balance after all transactions:\", total_balance)\n\n\n# Looping over strings\nmessage = \"Hello\"\n\nfor char in message:\n    print(char)\n\n\n\n3.3 Counter-based looping\nThe range() function is often used in for loops when you need to loop a specific number of times or generate a sequence of numbers.\n\nr = range(0, 8, 1)\nr\n\n\nlist(r)\n\n\ntype (r)\n\n\nfor i in range(5):\n    print(i)\n\n\nrange(5) generates a sequence of numbers from 0 to 4.\nOn each iteration, the variable i takes the value of the next number in the range.\n\n\nfor i in range(2,5):\n    print (l[i] ** 2)\n\n\n\n3.4 Nested for loops\nfor loops can be nested to iterate over multi-dimensional data structures like lists of lists or matrices:\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nfor row in matrix:\n    for item in row:\n        print(item, end=\" \")\n    print()  # Newline after each row\n\nIn this case: - The first line: for row in [[1, 2], [3, 4], [5, 6]] iterates over each row of the matrix. - The second line: for item in row iterates over each item in the row. - The item expression adds the individual elements to the new list.\n\n\n3.5 break and continue and else\n\nbreak: Exits the loop prematurely when a certain condition is met.\ncontinue: Skips the current iteration and moves on to the next iteration.\nelse: Executes after the loop completes normally (i.e., when the loop is not terminated by a break statement).\n\n\nfor num in range(1, 10):\n    if num == 5:\n        break  # Exit the loop when num equals 5\n    print(num)\n\n\nfor num in range(1, 6):\n    if num == 3:\n        continue  # Skip the iteration when num equals 3\n    print(num)\n\n\nfor num in range(1, 5):\n    print(num)\nelse:\n    print(\"Loop completed.\")\n\n\n# If the loop is interrupted by a break, the else block is not executed:\nfor num in range(1, 5):\n    if num == 3:\n        break\n    print(num)\nelse:\n    print(\"Loop completed.\")\n\n\n\n3.6 Looping and conditioning\n\nfor i in range (1,10):\n    if i % 2 == 0:\n        print (i, 'is even')\n    elif i % 3 == 0:\n        print (i, 'is a multiple of 3')\n    else:\n        print (i, 'is odd')\n\n\n\n3.7 List comprehension\nList comprehension is a concise way to create lists in Python. It combines a for loop and optional conditions into a single line of code, allowing to generate lists quickly and efficiently.\nIt is not only shorter but often more readable and efficient computationally than traditional for loops when dealing with list generation.\n\nBasic Syntax of List Comprehension\nnew_list = [expression for item in iterable if condition]\n\nexpression: The value to append to the new list.\nitem: The variable representing each element in the iterable (e.g., list, string, or range).\niterable: Any sequence or collection being iterated over (e.g., a list, tuple, string, or range).\ncondition: (Optional) A filter that includes only certain elements from the iterable. The condition is an if statement.\n\n\n#  Traditional `for` Loop:\nnumbers = [1, 2, 3, 4, 5]\nsquares = []\n\nfor number in numbers:\n    squares.append(number ** 2)\n\nprint(squares)\n\n\n# Equivalent List Comprehension:\nsquares = [number ** 2 for number in [1, 2, 3, 4, 5]]\nprint(squares)\n\nIn this case: - The for number in [1, 2, 3, 4, 5] part is the iteration. - The number ** 2 part is the expression that generates the square of each number.\n\n\nList comprehesions with condition\nif statement can be included in a list comprehension to filter elements.\n\n# Traditional `for` Loop with Condition:\nnumbers = [1, 2, 3, 4, 5, 6]\nevens = []\n\nfor number in numbers:\n    if number % 2 == 0:\n        evens.append(number)\n\nprint(evens)\n\n\n# Equivalent list comprehension with condition:\nevens = [number for number in [1, 2, 3, 4, 5, 6] if number % 2 == 0]\nprint(evens)\n\n\n# List comprehension with multiple conditions\nfiltered_numbers = [number for number in range(1, 21) if number % 2 == 0 and number % 3 == 0]\nprint(filtered_numbers)\n\n\n\nList comprehension with function calls\nFunction calls can be used in the expression part of a list comprehension.\n\ndef square(number):\n    return number ** 2\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = [square(number) for number in numbers]\n\n\n\nDictionary with list comprehension\nList comprehensions can be used to create dictionaries using the dict() constructor.\n\nnames = ['Alice', 'Bob', 'Charlie']\nname_length_dict = {name: len(name) for name in names}\n\nprint(name_length_dict)\n\n\n\nWhen to use list comprehensions\n\nConciseness: Generate lists quickly and concisely.\nReadability: For simple iterations, list comprehension is often more readable than multiple lines of for loops.\nEfficiency: List comprehensions are more efficient than traditional loops due to optimizations in Python’s internal implementation.\n\n\n\nWhen Not to Use List Comprehension\n\nComplex Logic: If the logic inside the list comprehension becomes too complex (e.g., multiple if conditions, nested loops), it may become less readable. In such cases, traditional loops may be clearer.\nSide Effects: List comprehensions should not be used if the logic involves side effects (e.g., modifying external variables or data structures), as they are primarily designed for list generation, not process flow control."
  }
]