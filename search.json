[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule Fall 2025",
    "section": "",
    "text": "Date\n#\nLecture\nTopic\n\n\n\n\n24/09/2025\n1\nNo Class\n\n\n\n01/10/2025  recorded\n2\nLecture 01\nIntroduction to Python\n\n\n\n\nLecture 02\nData types and structures\n\n\n08/10/2025  recorded\n3\nLecture 03\nControl structures\n\n\n\n\nLecture 04\nFunctions\n\n\n15/10/2025  recorded\n4\nLecture 05\nObject Oriented Programming\n\n\n\n\nLecture 06\nLibraries\n\n\n22/10/2025\n5\nLecture 07\nNumerical computing\n\n\n29/10/2025\n6\nNo class\n\n\n\n05/11/2025\n7\nLecture 08\nInput/output\n\n\n\n\nLecture 09\nData manipulation\n\n\n12/11/2025\n8\nLecture 10  [Guest Lecture]\nNetwork analytics\n\n\n19/11/2025\n9\nLecture 11\nTime series analysis\n\n\n26/11/2025\n10\nLecture 12\nMachine Learning\n\n\n03/12/2025\n11\nNo Class\n\n\n\n10/12/2025\n12\nLecture 13  [Guest Lecture]\nAdvanced Machine Learning\n\n\n17/12/2025\n13\nQ&A"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03_problem_sets.html",
    "href": "lectures/lecture_03/lecture_03_problem_sets.html",
    "title": "Controle Structures - Problem Set",
    "section": "",
    "text": "Write a Python program that takes a user’s income and tax status as input. If the income is greater than $50,000, they should be taxed at 25%. Otherwise, they are taxed at 15%. Print the amount of tax they owe.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03_problem_sets.html#more-exercises-on-list-comprehension",
    "href": "lectures/lecture_03/lecture_03_problem_sets.html#more-exercises-on-list-comprehension",
    "title": "Controle Structures - Problem Set",
    "section": "More exercises on list comprehension",
    "text": "More exercises on list comprehension\n\nExercise 1: Convert Temperatures\nGiven a list of temperatures in Celsius, use list comprehension to convert them to Fahrenheit. The formula for conversion is:\n\\[\n    F = \\frac{9}{5} \\times C + 32\n\\]\n\ncelsius = [0, 20, 37, 100]\n# Write the list comprehension to convert celsius to fahrenheit\n\n\n\nExercise 2: Filter and Square Odd Numbers\nGiven a list of numbers, use list comprehension to create a new list containing the squares of the odd numbers only.\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# Write the list comprehension to filter and square odd numbers\n\n\n\nExercise 3: Extract Vowels from a String\nGiven a string, use list comprehension to create a list of all the vowels in the string.\n\ntext = \"List comprehensions are very powerful!\"\n# Write the list comprehension to extract vowels from the string\n\n\n\nExercise 4: Flatten a Nested List\nGiven a list of lists (nested list), use list comprehension to flatten it into a single list.\n\nnested_list = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\n# Write the list comprehension to flatten the nested list\n\n\n\nExercise 5: Dictionary from List\nYou have a list of tuples where the first element is a country and the second element is its population. Use list comprehension to convert the list of tuples into a dictionary.\n\ncountries = [(\"USA\", 331002651), (\"India\", 1380004385), (\"China\", 1439323776)]\n# Write the list comprehension to convert the list into a dictionary"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04_problem_sets.html",
    "href": "lectures/lecture_04/lecture_04_problem_sets.html",
    "title": "Functions - Problem Set",
    "section": "",
    "text": "Exercise 1: Greeting Function\nWrite a function called greet_user(name) that takes a person’s name as a parameter and prints a greeting message.\n\n# Your code\n\n\n\nExercise 2: Sum of Two Numbers\nCreate a function called sum_two_numbers(a, b) that takes two numbers as arguments and returns their sum.\n\n# Your code\n\n\n\nExercise 3: Convert Celsius to Fahrenheit\nWrite a function celsius_to_fahrenheit(celsius) that takes a temperature in Celsius and returns the temperature in Fahrenheit. Use the formula:\n\\[\n    F = \\frac{9}{5} \\times C + 32\n\\]\n\n# Your code\n\n\n\nExercise 4: Calculate Area of Circle\nCreate a function called calculate_circle_area(radius) that takes the radius of a circle and returns the area of the circle using the formula:\n\\[\n    A = \\pi \\times r^2\n\\]\n\n# Your code\n\n\n\nExercise 5: Simple Interest\nWrite a function calculate_simple_interest(principal, rate, time) that calculates simple interest and returns it. The formula is:\n\\[\n    \\text{Interest} = \\frac{P \\times R \\times T}{100}\n\\]\n\n# Your code\n\n\n\nExercise 6: Compound Interest\nModify the function calculate_compound_interest(principal, rate, time) to return both the compound interest and the total amount (principal + interest).\n\n# Your code\n\n\n\nExercise 7: Maximum of Three Numbers\nCreate a function max_of_three(a, b, c) that takes three numbers as input and returns the largest of the three.\n\n# Your code\n\n\n\nExercise 8: Check Even or Odd with Lambda\nUse a lambda function to check whether a number is even or odd. Write a function is_even_or_odd(number) that returns “even” if the number is even and “odd” if the number is odd.\n\n# Your code\n\n\n\nExercise 9: Sum of Squares using map()\nUse map() and a lambda function to create a list of squares of numbers from 1 to 10.\n\n# Your code\n\n\n\nExercise 10: Filter Positive Numbers\nWrite a function filter_positive(numbers) that takes a list of numbers and uses the filter() function to return a list of only positive numbers.\n\n# Your code\n\n\n\nAdvanced Exercise 1: Recursive Factorial Function\nWrite a recursive function factorial(n) that takes a number n and returns the factorial of n.\n\n# Your code\n\n\n\nAdvanced Exercise 2: Higher-Order Function for Applying Functions\nCreate a higher-order function apply_function(func, x) that takes a function and a value x, and applies the function to x twice.\n\n# Your code\n\n\n\nAdvanced Exercise 3: Net Present Value (NPV) with Lambda\nWrite a function calculate_npv(cash_flows, rate) that calculates the Net Present Value (NPV) of cash flows using a lambda function inside a list comprehension. Assume cash_flows is a list and rate is a constant discount rate.\n\n# Your code\n\n\n\nAdvanced Exercise 4: Zip and Sort\nWrite a function zip_and_sort(names, scores) that takes two lists: names (list of students’ names) and scores (list of their scores). Use zip() to combine the two lists into tuples, then return the list of students sorted by their scores in descending order.\n\n# Your code\n\n\n\nAdvanced Exercise 5: Reduce for Cumulative Product\nUse the reduce() function to write a function cumulative_product(numbers) that takes a list of numbers and returns their cumulative product.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html",
    "href": "lectures/lecture_04/lecture_04.html",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#lecture-material",
    "href": "lectures/lecture_04/lecture_04.html#lecture-material",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#recording",
    "href": "lectures/lecture_04/lecture_04.html#recording",
    "title": "Lecture 04 - Functions",
    "section": "Recording",
    "text": "Recording\n\n1. Intro\n\n \n\n\n\n2. Basics\n\n \n\n\n\n3. Functional Programming"
  },
  {
    "objectID": "lectures/lecture_04/lecture_04.html#problem-sets",
    "href": "lectures/lecture_04/lecture_04.html#problem-sets",
    "title": "Lecture 04 - Functions",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)\nSolutions (.pdf)"
  },
  {
    "objectID": "lectures/lecture_05/oop.html",
    "href": "lectures/lecture_05/oop.html",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "",
    "text": "Object-Oriented Programming (OOP) is a programming paradigm based on the concept of class and objects which can contain\n\nData (attributes)\nCode (methods)\n\nWhy does OOP matter?\nOOP allows for organizing complex programs into manageable, modular components, making the code more: - Reusable: Once a class is created, it can be used across different parts of the program without rewriting. - Scalable: Capacity to build on existing structures without rewriting them. - Maintainable: Since the code is organized into discrete components, fixing bugs and adding new features is straightforward.\nThis notebook covers: - The basics of OOP: classes and objects - Defining classes and creating objects - Attributes and methods - Inheritance and polymorphism"
  },
  {
    "objectID": "lectures/lecture_05/oop.html#overview",
    "href": "lectures/lecture_05/oop.html#overview",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "",
    "text": "Object-Oriented Programming (OOP) is a programming paradigm based on the concept of class and objects which can contain\n\nData (attributes)\nCode (methods)\n\nWhy does OOP matter?\nOOP allows for organizing complex programs into manageable, modular components, making the code more: - Reusable: Once a class is created, it can be used across different parts of the program without rewriting. - Scalable: Capacity to build on existing structures without rewriting them. - Maintainable: Since the code is organized into discrete components, fixing bugs and adding new features is straightforward.\nThis notebook covers: - The basics of OOP: classes and objects - Defining classes and creating objects - Attributes and methods - Inheritance and polymorphism"
  },
  {
    "objectID": "lectures/lecture_05/oop.html#the-basics-of-oop-classes-and-objects",
    "href": "lectures/lecture_05/oop.html#the-basics-of-oop-classes-and-objects",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "1. The Basics of OOP: Classes and Objects",
    "text": "1. The Basics of OOP: Classes and Objects\n\n1.1 Definitions\nWhat is a Class?\nA class is like a blueprint or template for creating objects.\nIt defines the attributes (variables) and methods (functions) that objects created from the class will have.\nWhat is an Object?\nAn object is an instance of a class. It has its own specific values for the attributes defined by the class.\nWhy use Classes and Objects?\nClasses are like cookie cutters and objects are the actual cookies.\nThe class defines the shape and structure, while each object is an independent instance that can have different values but shares the same structure.\n\n\n1.2 Syntax\n\nGeneral\nIn general, a class is alway defined by a constructor and a set of methods and attributes.\n    class NAME:\n        CONSTRUCTOR\n        OTHER METHODS\n        ATTRIBUTES\n\nThe Constructor sets up initial values for attributes when an object is created. This ensures that each object starts in a well-defined state.\nThe Methods are callable functions within and outside the class object\nThe Attributes are callable variables withing and outside the class object\n\n\n\nIn Python\n    class NAME:\n        def __init__(self, ...):\n            ACTIONS\n            \n        def METHODS (self,...):\n            ACTIONS\n        \n        self.ATTRIBUTES\n\nConstructor is defined by the function init() where self is a reference to the class object itself.\nMethods are defined like standard functions.\n\nReference to attributes that belong to the current class object in the constructor and methods are specified using the prefix self.\n\n\n\n\n\n1.3 Example\nConsider a simple example of a bank account. Each bank account will have: 1. An account holder. 2. A balance that tracks the amount of money in the account.\n\nclass BankAccount:\n    # constructor\n    def __init__(self, account_holder, balance=0):\n        self.account_holder = account_holder  # Assigning account holder name\n        self.balance = balance  # Setting initial balance (default is 0)\n\n\n# Creating an instance of BankAccount\naccount1 = BankAccount(\"John Doe\", 500)\n\n\n# Accessing attributes of the object\nprint(f\"Account Holder: {account1.account_holder}\")  # Output: John Doe\nprint(f\"Balance: {account1.balance}\")  # Output: 500\n\n\n\nStep-by-step Explanation:\n\nClass Definition: We define the BankAccount class.\nConstructor (__init__ method): This method initializes the attributes account_holder and balance when a new BankAccount object is created.\nCreating an Object: We create an object account1 of the BankAccount class.\nAccessing Object Attributes: We print the values of the object’s attributes using the dot notation (e.g., account1.balance)."
  },
  {
    "objectID": "lectures/lecture_05/oop.html#attributes-and-methods",
    "href": "lectures/lecture_05/oop.html#attributes-and-methods",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "2. Attributes and Methods",
    "text": "2. Attributes and Methods\n\n2.1 Attributes\nAttributes are variables that hold data specific to an object.\nThey are defined within a class and belong to each instance of that class.\nWhy are attributes important?\nAttributes store the state of the object.\nIn the bank account example, the balance attribute holds the current state of the account.\n\n\n2.2 Methods\nMethods are functions defined inside a class that operate on objects of that class.\nMethods can read or modify the object’s attributes.\nWhy use Methods?\nMethods define behaviors specific to the class.\n\n\n2.3 Example\nLet’s add some functionality to our BankAccount class.\nWe want to be able to:\n\nDeposit money into the account.\nWithdraw money from the account.\n\n\nclass BankAccount:\n    # Constructor\n    def __init__(self, account_holder, balance=0):\n        self.account_holder = account_holder\n        self.balance = balance\n\n    # Method for depositing money\n    def deposit(self, amount):\n        self.balance += amount\n        print(f\"Deposited {amount}. New balance is {self.balance}\")\n\n    # Method for withdrawing money\n    def withdraw(self, amount):\n        if amount &gt; self.balance:\n            print(\"Insufficient funds.\")\n        else:\n            self.balance -= amount\n            print(f\"Withdrew {amount}. New balance is {self.balance}\")\n\n\n# Creating a new BankAccount object\naccount2 = BankAccount(\"Jane Doe\", 1000)\naccount2.deposit(200)  # Depositing 200\naccount2.withdraw(300)  # Withdrawing 300\n\n\n\n2.4 Additional examples\nDefine a Student class with the following attributes: - name - student_id - grade\nAdd methods to: 1. Update the grade. 2. Print a summary of the student’s information.\n\n# Defining the Student class\nclass Student:\n    # Constructor to initialize the attributes of the class\n    def __init__(self, name, student_id, grade):\n        self.name = name            # Student's name\n        self.student_id = student_id  # Unique student ID\n        self.grade = grade          # Current grade of the student\n\n    # Method to update the student's grade\n    def update_grade(self, new_grade):\n        self.grade = new_grade\n        print(f\"Grade updated to: {self.grade}\")\n\n    # Method to print a summary of the student's information\n    def print_summary(self):\n        print(f\"Student Name: {self.name}\")\n        print(f\"Student ID: {self.student_id}\")\n        print(f\"Current Grade: {self.grade}\")\n\n\n# Creating an instance of the Student class\nstudent1 = Student(\"Alice\", 12345, \"80\")\n\n\n# Calling the methods to test the functionality\nstudent1.print_summary()  # Printing the initial student details\n\n\n# Updating the grade and printing the updated details\nstudent1.update_grade(\"90\")\nstudent1.print_summary()  # Should show the updated grade\n\nAdditional methods to implement - has_failed() - can_retake() – cannot fail more than twice\n\n# Your code\n\nGlobal exercise\nFrom a list of objects Student, order students from highest to lowest grade\n\n# Creating a list of multiple Student objects with varying grades\nstudents = [\n    Student(\"Alice\", 12345, \"80\"),\n    Student(\"Bob\", 67890, \"40\"),\n    Student(\"Charlie\", 54321, \"60\"),\n    Student(\"David\", 98765, \"99\"),\n    Student(\"Eve\", 45678, \"21\")\n]\n\n# Function to sort the list of students by their grades\ndef sort_students_by_grade(student_list):\n    # Sort by grade in ascending order (A &gt; B &gt; C)\n    sorted_students = sorted(student_list, key=lambda student: student.grade)\n    return sorted_students\n\n# Sorting the students and printing the result\nsorted_students = sort_students_by_grade(students)\n\n# Displaying the sorted list of students\nprint(\"Students sorted by grades:\")\nfor student in sorted_students:\n    student.print_summary()"
  },
  {
    "objectID": "lectures/lecture_05/oop.html#inheritance",
    "href": "lectures/lecture_05/oop.html#inheritance",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "3. Inheritance",
    "text": "3. Inheritance\nInheritance is a fundamental concept in object-oriented programming that allows a new class to inherit attributes and methods from an existing class.\nThis existing class is known as the parent class (or base class), while the new class is referred to as the child class (or derived class).\nWhy use inheritance?\n\nCode Reusability: Inheritance helps reduce code duplication by allowing new classes to use the features of existing classes.\nLogical Hierarchies: Model real-world relationships, such as “A Car is-a Vehicle.”\nExtendability: Add new features to the child class without modifying the parent class, making it easier to maintain the code.\n\nHow it works\nWhen creating a child class, the class automatically inherits all the attributes and methods of the parent class.\nHowever, the functionality of the parent class can also be extended or overridden within the child class.\n\n3.1 Syntax\n    class CHILD (PARENT):\n        def __init__(self,...):\n            super().__init__(...):\n            self....\n\n\n3.2 Step-by-step example\nStep 1: Create a parent class\nStart with a Person class that has basic attributes like name and age, and a method to print a summary.\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def display(self):\n        print(f\"Name: {self.name}, Age: {self.age}\")\n\n\nThe Person class has two attributes: name and age.\nIt includes a method display() that prints the name and age.\n\nStep 2: Create a child class that inherits from Person\nNow let’s create a Student class that inherits from the Person class.\nThe Student class will have an additional attribute grade and its own method to print details specific to students.\n\nclass Student(Person):\n    def __init__(self, name, age, grade):\n        # Call the constructor of the parent class\n        super().__init__(name, age)  \n        self.grade = grade  # New attribute specific to Student\n\n    def display_student(self):\n        print(f\"Student Name: {self.name}, Age: {self.age}, Grade: {self.grade}\")\n\n\nThe Student class inherits from the Person class using class Student(Person):.\nThe Student class has its own constructor (__init__) that calls the constructor of the parent class using super().__init__(name, age).\n\nThis is necessary to properly initialize attributes from the parent class.\n\nThe Student class has a new attribute grade and a new method display_student().\n\nStep 3: Creating objects and using inheritance\nNow that we have both classes, let’s create a Student object and use the inherited and new methods.\n\n# Creating an instance of the Student class\nstudent1 = Student(\"Alice\", 20, \"A\")\n\n# Calling methods\nstudent1.display()  # Inherited method from Person class\nstudent1.display_student()  # Method specific to Student class\n\n\nThe student1.display() call demonstrates inherited behavior:\n\ndisplay() is defined in Person, but student1 (an instance of Student) can use it because Student inherits from Person.\n\nThe student1.display_student() call demonstrates extended behavior:\n\ndisplay_student() is defined only in the Student class.\n\n\n\n\n3.3 Other Example\nLet’s create a new class called SavingsAccount that inherits from BankAccount.\nA savings account might have an interest rate and a method to apply interest.\n\n# Inheriting from BankAccount class\nclass SavingsAccount(BankAccount):\n    def __init__(self, account_holder, balance=0, interest_rate=0.02):\n        # Call the parent class constructor\n        super().__init__(account_holder, balance)\n        self.interest_rate = interest_rate  # Additional attribute for interest rate\n\n    # New method to apply interest\n    def apply_interest(self):\n        interest = self.balance * self.interest_rate\n        self.deposit(interest)  # Use deposit method to add interest\n        print(f\"Interest applied. New balance: {self.balance}\")\n\n\n# Creating a SavingsAccount object\nsavings = SavingsAccount(\"Alice\", 2000)\nsavings.apply_interest()"
  },
  {
    "objectID": "lectures/lecture_05/oop.html#method-overriding-and-polymorphism",
    "href": "lectures/lecture_05/oop.html#method-overriding-and-polymorphism",
    "title": "Lecture 05 - Object-Oriented Programming",
    "section": "4. Method Overriding and Polymorphism",
    "text": "4. Method Overriding and Polymorphism\n\n4.1 Method Overriding\nMethod overriding occurs when a child class provides a specific implementation for a method that is already defined in its parent class.\nThis allows the child class to define its own behavior for the inherited method.\n\nPurpose: To customize or extend the behavior of a method in the child class.\nSyntax: A method in the child class has the same name, parameters, and return type as a method in the parent class.\n\n\n# Parent class\nclass Vehicle:\n    def move(self):\n        print(\"The vehicle is moving\")\n\n# Child class overriding the move method\nclass Car(Vehicle):\n    def move(self):\n        print(\"The car is driving on the road\")\n\n# Creating instances\nv = Vehicle()\nc = Car()\n\n# Calling the move method\nv.move()  \nc.move()  \n\n\nExample\nLet’s override the display() method in the Student class to show the grade as well:\n\nclass Student(Person):\n    def __init__(self, name, age, grade):\n        super().__init__(name, age)\n        self.grade = grade\n\n    # Overriding the display method from Person class\n    def display(self):\n        print(f\"Name: {self.name}, Age: {self.age}, Grade: {self.grade}\")\n\n\nstudent1 = Student(\"Bob\", 21, \"B\")\nstudent1.display()  \n\n\n\nOther Example:\nLet’s override the withdraw() method from BankAccount to SavingsAccount.\nIf a SavingsAccount has different withdrawal rules (e.g., no withdrawals below a minimum balance), we can override the withdraw method.\n\nclass SavingsAccount(BankAccount):\n    def __init__(self, account_holder, balance=0, interest_rate=0.02):\n        super().__init__(account_holder, balance)\n        self.interest_rate = interest_rate\n\n    def withdraw(self, amount):\n        if self.balance - amount &lt; 500:  # Minimum balance of 500\n            print(\"Withdrawal denied: Balance cannot go below 500.\")\n        else:\n            super().withdraw(amount)  # Call the parent class method\n\n\n\n\n4.2 Polymorphism\nPolymorphism means “many forms” and refers to the ability of different classes to respond to the same method call in different ways.\nIt allows the same method name to be used for different types of objects.\nPurpose: To enable objects of different classes to be treated as objects of a common parent class.\n\n# Parent class\nclass Animal:\n    def sound(self):\n        raise NotImplementedError(\"Subclasses must implement this method\")\n\n# Child classes\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\n# Polymorphism: List of different objects\nanimals = [Dog(), Cat()]\n\n# Using polymorphism to call the same method\nfor animal in animals:\n    print(animal.sound())  # Output: Bark, Meow\n\nIn the above example: 1. Both Dog and Cat classes override the sound() method of the Animal parent class. 2. When we call sound() on each object, polymorphism ensures that the correct implementation is executed based on the type of the object (Dog or Cat).\n\n\n4.3 Take-away\n\nMethod overriding is a technique that allows polymorphism to occur.\n\nWhen a child class overrides a method, it enables polymorphism because objects of different classes can respond to the same method call in their own unique way.\n\nPolymorphism is a broader concept that encompasses method overriding as a way to implement it.\n\nVisual Analogy:\n\nMethod Overriding ~ customizing a basic recipe.\n\nIf the parent class provides a recipe for a “generic cake,” the child class can override this recipe to make a “chocolate cake.”\n\nPolymorphism ~ ability to treat both the “generic cake” and “chocolate cake” as simply “cakes” when needed.\n\nCall bake() on both and get the right result, even if the recipes are different."
  },
  {
    "objectID": "lectures/lecture_02/lecture_02_problem_sets.html",
    "href": "lectures/lecture_02/lecture_02_problem_sets.html",
    "title": "Data Types and Structures - Problem sets",
    "section": "",
    "text": "Exercise 1: Check Data Types\nWrite a Python program that prints the data types of the following variables:\na = 42\nb = 3.14\nc = \"Python\"\nd = [1, 2, 3]\ne = (1, 2, 3)\nf = {'name': 'John', 'age': 30}\ng = {1, 2, 3}\n\n# Your code\n\n\n\nExercise 2: List Operations\nCreate a list with the elements [10, 20, 30, 40, 50]. Add 60 to the list, remove 30, and reverse the list.\n\n# Your code\n\n\n\nExercise 3: Tuple Unpacking\nGiven the following tuple, unpack its elements into separate variables and print them:\nmy_tuple = (100, 200, 300)\n\n# Your code\n\n\n\nExercise 4: Dictionary Manipulation\nCreate a dictionary with keys 'name', 'age', and 'city', and values 'Alice', 25, and 'New York'. Update the age to 26 and add a new key 'profession' with value 'Engineer'.\n\n# Your code\n\n\n\nExercise 5: Set Operations\nCreate two sets, set1 with elements {1, 2, 3, 4} and set2 with elements {3, 4, 5, 6}. Find the union, intersection, and difference between these sets.\n\n# Your code\n\n\n\nExercise 6: String Slicing\nGiven the string s = \"Hello, Python!\", write code to: 1. Extract the substring \"Python\". 2. Reverse the entire string.\n\n# Your code\n\n\n\nExercise 7: Boolean Logic\nYou are given three numbers, a, b, and c. Write a Python program that returns True if a is the largest number and b is not equal to c. Otherwise, return False.\n\n# Input numbers\na = 10\nb = 5\nc = 5\n\n# Your code\n\n\n\nExercise 8: Complex Boolean Logic with Multiple Conditions\nWrite a Python program that checks the following conditions for three variables x, y, and z:\n\nx is greater than y or y is equal to z.\nThe sum of x and y is even.\nx, y, and z are all positive numbers.\n\nThe program should return True only if all three conditions are met.\n\n# Input variables\nx = 8\ny = 6\nz = 6\n\n# Your code\n\n\n\nExercise 9: Checking for Keys in a Dictionary\nGiven the dictionary person = {'name': 'Bob', 'age': 25}, check if the key 'age' exists in the dictionary and print a message.\n\n# Your code\n\n\n\nExercise 10: Nested Data Structures\nCreate a dictionary students where each key is a student’s name and each value is a dictionary containing their 'age' and a list of their 'grades'.\nEnter the following data in the dictionary: - Alice is 24 and has grades 88, 92 and 86 - Bob is 23 and had grades 75, 80, 89\nPrint Bob’s age and Alice’s grades.\n\n# Your code"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html",
    "href": "lectures/lecture_02/data_types_and_structure.html",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "",
    "text": "In Python, types and structures are fundamental concepts that allow the storage, manipulation, and organization of data.\nThis notebook covers:\n\nBasic data types: int, float, bool, str\nData structures: tuple, list, set, dict\nOperations and built-in methods"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#overview",
    "href": "lectures/lecture_02/data_types_and_structure.html#overview",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "",
    "text": "In Python, types and structures are fundamental concepts that allow the storage, manipulation, and organization of data.\nThis notebook covers:\n\nBasic data types: int, float, bool, str\nData structures: tuple, list, set, dict\nOperations and built-in methods"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#basic-types",
    "href": "lectures/lecture_02/data_types_and_structure.html#basic-types",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "1. Basic Types",
    "text": "1. Basic Types\nList of types\n\n\n\nObject type\nMeaning\nUsed for\n\n\n\n\nint\ninteger value\nnatural numbers\n\n\nfloat\nfloating-point number\nreal numbers\n\n\nbool\nboolean value\ntrue or false\n\n\nstr\nstring object\ncharacter, word, text\n\n\n\nuse built-in function type() to obtain the information\n\n1.1 Integers and Floats\nIntegers are whole numbers, while floats are numbers with decimal values.\n\nInt\n\na = 10\ntype(a)\n\nArithmetic operations: + - * /\n\n1 + 4 \n\n\na + 1\n\n\ntype(1+4)\n\n\n\nFloats\n\ntype (1/4)\n\n\n1/4\n\n\ntype(0.25)\n\n\ntype (0)\n\n\ntype (0.0)\n\n\n# Example: Representing account balances\nbalance = 1000  # Integer\ninterest_rate = 5.5  # Float\n\n\n# Calculating interest\ninterest = balance * interest_rate / 100\nprint(\"Interest:\", interest)\n\n\n\n\n1.2 Booleans\nBooleans represent True or False values.\n\n# Example: Checking if an account is active\naccount_active = True\nif account_active == True:\n    print(\"The account is active.\")\nelse:\n    print(\"The account is inactive.\")\n\n\n# implicit comparison\nif account_active:\n    print(\"The account is active.\")\nelse:\n    print(\"The account is inactive.\")\n\n\nConditions: &gt; &lt; &gt;= &lt;= == !=\n\n4 &gt; 3\n\n\ntype (4 &gt; 3)\n\n\ntype (False)\n\n\n4 &gt;= 3\n\n\n4 &lt; 3\n\n\n4 == 3\n\n\n4 != 3\n\n\n\nLogic operations: and or not in\n\nTrue and True\n\n\nFalse and False\n\n\nTrue or True\n\n\nTrue or False\n\n\nFalse or False\n\n\nnot True\n\n\nnot False\n\n\n\nCombinations\n\n(4 &gt; 3) and (2 &gt; 3)\n\n\n(4==3) or (2 != 3)\n\n\nnot (4 != 4)\n\n\n(not (4 != 4)) and (2 == 3)\n\nNote: Major for control condition (if while for) – see later\n\nif 4 &gt; 3:\n    print ('condition true')\nelse:\n    print ('condition not true')\n\n\ni = 0\nwhile i &lt; 4:\n    print ('condition true: i = ', i)\n    i = i + 1\n\n\n\nBoolean casting: 0,1 (and other values)\n\nint(True)\n\n\nint(False)\n\n\nfloat(True)\n\n\nfloat(False)\n\n\nbool(0)\n\n\nbool(1)\n\n\nbool(0.0)\n\n\nbool(1.0)\n\n\nbool(10.5)\n\n\nbool(-2)\n\n\n\n\n1.3 Strings\nStrings are used to represent text.\n\n# Example: Representing account holder information\naccount_holder = \"John Doe\"\naccount_number = \"1234567890\"\n\nprint(\"Account Holder:\", account_holder)\nprint(\"Account Number:\", account_number)\n\n\ntype(account_holder)\n\n\nBuilt-in methods\nstr variables come with a series of useful built-in methods.\n\n\n\nMethod\n\n\n\n\ncapitalize()\n\n\ncount()\n\n\nfind()\n\n\njoin()\n\n\nreplace()\n\n\nsplit()\n\n\nupper()\n\n\n\n\nt = 'this is a string object'\n\n\nt.capitalize()\n\n\nt.split('i')\n\n\nt.find('string')\n\n\nt.replace(' ','|')\n\n\n\nPrint method print()\n\nprint('Hello World!')\n\n\nprint (t)\n\n\ni = 0\nwhile i &lt; 4:\n    print (i)\n    i = i + 1\n\n\ni = 0\nwhile i &lt; 4:\n    print (i, end = '|')\n    i = i + 1\n\n\n\nPrinting with variables\n\na = 10\nprint('this is the value of a:', a)\n\n\ntt = 'this is the value of a: ' + str(a)\nprint (tt)"
  },
  {
    "objectID": "lectures/lecture_02/data_types_and_structure.html#basic-structures",
    "href": "lectures/lecture_02/data_types_and_structure.html#basic-structures",
    "title": "Lecture 02 - Data Types and Structures",
    "section": "2. Basic structures",
    "text": "2. Basic structures\nList of structures\n\n\n\nObject type\nMeaning\nUsed for\n\n\n\n\ntuple\nimmutable container\nfixed set of objects\n\n\nlist\nmutable container\nordered and changing set of objects\n\n\ndict\nmutable container\nkey-value store\n\n\nset\nmutable container\nunordered collection of unique objects\n\n\n\nuse built-in function type() to obtain the information\nNavigating structures\n\nIndexing: obtain item at position n s[n]\nSlicing: obtain items between position i and j s[i:j] s[i:] s[:j]\nRanging: obtain items between position i and j spaced by k s[i:j:k]\n\nNote: In Python, indexing starts at 0\n\n2.1 tuple\nTuples are immutable collections of items (i.e., cannot be changed after creation).\n\n# Example: Coordinates of a bank branch\nbranch_location = (40.7128, -74.0060)  # New York City coordinates\nprint(\"Branch Location:\", branch_location)\n\n\nt = (1, 2.5, 'data')\ntype(t)\n\n\n#also works without ()\nt = 1, 2.5, 'data'\ntype(t)\n\n\n#indexing\nt[2]\n\n\ntype(t[2])\n\n\n\n2.2 list\nLists are ordered collections of items, which can be of mixed data types.\n\n# Example: List of recent transactions\ntransactions = [100, -50, 200, -30, 400]\nprint(\"Transactions:\", transactions)\n\n# Adding a new transaction\ntransactions.append(-100)\nprint(\"Updated Transactions:\", transactions)\n\n\nl = [1, 2.5, 'data']\nl[2]\n\n\n#casting\nl = list(t)\nl\n\n\ntype (l)\n\n\nBuilt-in methods\n\n\n\nMethod\n\n\n\n\nl[i] = x\n\n\nl[i:j:k] = s\n\n\nappend()\n\n\ncount()\n\n\ndel l[i:j:k]\n\n\nindex()\n\n\nextend()\n\n\ninsert()\n\n\nremove()\n\n\npop()\n\n\nrevers()\n\n\nsort()\n\n\n\ncontrary to tuples, lists are mutable containers\n\nl.append([4,3])\nl\n\n\nl.extend([1.0, 1.5, 2.0])\nl\n\n\nl = [0, 1, 2, 3, 4, 5, 6, 7]\ns = [10, 20, 30]\n\nl[1:7:2] = s\nprint(l)\n\n\nl.insert(1,'insert')\nl\n\n\nl.remove('data')\nl\n\n\np = l.pop(3)\nprint (l, p)\n\n\n#slicing\nl[2:5]\n\nMutable vs immutable objects\n\nt = (1, [2, 3], 4)\n\n\nt[1].append(5)    \n\n\nprint(t)          \n\n\nt[0] = 9\n\n\n\n\n2.3 dict\nDictionaries store data as key-value pairs.\n\n# Example: Dictionary of account balances\naccount_balances = {\n    \"1234567890\": 1000,\n    \"0987654321\": 2500,\n    \"1122334455\": 750\n}\nprint(\"Account Balances:\", account_balances)\n\n# Accessing a balance by account number\nprint(\"Balance of account 1234567890:\", account_balances[\"1234567890\"])\n\n\nKeys and values\n\nd = {\n    'Name' : 'Iron Man',\n    'Country' : 'USA',\n    'Profession' : 'Super Hero',\n    'Age' : 36\n}\n\n\ntype(d)\n\n\nprint (d['Name'], d['Age'])\n\n\n\nBuilt-in methods\n\n\n\nMethod\n\n\n\n\nd[k]\n\n\nd[k] = x\n\n\ndel d[k]\n\n\nclear()\n\n\ncopy()\n\n\nitems()\n\n\nkeys()\n\n\nvalues()\n\n\npopitem()\n\n\nupdate()\n\n\n\n\nd.keys()\n\n\nd.values()\n\n\nd.items()\n\n\nbirthday = True\nif birthday:\n    d['Age'] += 1\nprint (d['Age'])\n\n\nfor item in d.items():\n    print (item)\n\n\nfor value in d.values():\n    print (type(value))\n\n\n\n\n2.4 set\nSets are unordered collections of unique items.\n\ns = set(['u', 'd', 'ud', 'du', 'd', 'du'])\ns\n\n\nSet operations\n\nt = set(['d', 'dd', 'uu', 'u'])\n\n\ns.union(t)\n\n\ns.intersection(t)\n\n\ns.difference(t)\n\n\nt.difference(s)\n\n\ns.symmetric_difference(t)"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html",
    "href": "lectures/lecture_01/lecture_01.html",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html#lecture-material",
    "href": "lectures/lecture_01/lecture_01.html#lecture-material",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_01/lecture_01.html#recording",
    "href": "lectures/lecture_01/lecture_01.html#recording",
    "title": "Lecture 01 - Introduction to Python",
    "section": "Recording",
    "text": "Recording\n\n1. Motivation\n\n \n\n\n\n2. Setting up the environment\n\n \n\n\n\n3. Overview of the Python environment"
  },
  {
    "objectID": "lectures/lecture_06/libraries.html",
    "href": "lectures/lecture_06/libraries.html",
    "title": "Lecture 06 - Libraries",
    "section": "",
    "text": "Python libraries are collections of modules and functions that provide additional functionality, allowing to perform complex tasks with minimal code.\nIn this notebook covers: - Why Python libraries are important - How to install and import libraries - Key Python libraries used in banking and finance - pandas for data manipulation - numpy for numerical computations - matplotlib and seaborn for data visualization - datetime for date and time manipulation"
  },
  {
    "objectID": "lectures/lecture_06/libraries.html#overview",
    "href": "lectures/lecture_06/libraries.html#overview",
    "title": "Lecture 06 - Libraries",
    "section": "",
    "text": "Python libraries are collections of modules and functions that provide additional functionality, allowing to perform complex tasks with minimal code.\nIn this notebook covers: - Why Python libraries are important - How to install and import libraries - Key Python libraries used in banking and finance - pandas for data manipulation - numpy for numerical computations - matplotlib and seaborn for data visualization - datetime for date and time manipulation"
  },
  {
    "objectID": "lectures/lecture_06/libraries.html#why-use-python-libraries",
    "href": "lectures/lecture_06/libraries.html#why-use-python-libraries",
    "title": "Lecture 06 - Libraries",
    "section": "1. Why Use Python Libraries?",
    "text": "1. Why Use Python Libraries?\nPython libraries allow to: - Reuse code that has been tested and optimized by others - Perform complex tasks with just a few lines of code - Simplify workflow by providing tools tailored to specific tasks\n\nExample: Using a Library vs. Writing Code from Scratch\n\n# Without using a library\n# Calculate the square root of a number (writing the logic from scratch)\ndef sqrt(number):\n    return number ** 0.5\n\nprint(\"Square root of 16 (without library):\", sqrt(16))\n\n\n# Using a library (numpy)\nimport numpy as np\nprint(\"Square root of 16 (using numpy):\", np.sqrt(16))"
  },
  {
    "objectID": "lectures/lecture_06/libraries.html#installing-and-importing-libraries",
    "href": "lectures/lecture_06/libraries.html#installing-and-importing-libraries",
    "title": "Lecture 06 - Libraries",
    "section": "2. Installing and Importing Libraries",
    "text": "2. Installing and Importing Libraries\nTo use a library, it needs to be installed (if it’s not already installed) and be imported it into the current Python environment.\n\n2.1 Installing Libraries\n\nUsing pip, the Python package installer. For example:\n\npip install pandas numpy matplotlib seaborn\n\nUsing the anaconda suite to install manually.\n\n\n\n2.2 Importing Libraries\nOnce installed, libraries can be imported into the environment using import (...as):\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns"
  },
  {
    "objectID": "lectures/lecture_06/libraries.html#key-python-libraries-for-data-science-in-finance",
    "href": "lectures/lecture_06/libraries.html#key-python-libraries-for-data-science-in-finance",
    "title": "Lecture 06 - Libraries",
    "section": "3. Key Python Libraries for Data Science in Finance",
    "text": "3. Key Python Libraries for Data Science in Finance\n\n3.1 numpy for Numerical Computations\nnumpy is the foundational package for numerical computing in Python. It is particularly useful for handling large arrays and matrices of numeric data.\n\nimport numpy as np\n\n# Example: Calculating compound interest using numpy\nprincipal = 1000  # Initial amount\nrate = 0.05  # Interest rate\ntime = 10  # Number of years\n\n# Calculate the future value\nfuture_value = principal * np.power(1 + rate, time)\nprint(\"Future Value after 10 years:\", future_value)\n\n\n\n3.2 pandas for Data Manipulation\npandas is a powerful library for data manipulation and analysis. It works with structured data, such as CSV files, databases, and Excel spreadsheets.\n\nimport pandas as pd\n\n# Example: Reading a CSV file containing transaction data\ntransactions = pd.DataFrame({\n    'Date': ['2023-08-01', '2023-08-02', '2023-08-03'],\n    'Description': ['Deposit', 'Withdrawal', 'Deposit'],\n    'Amount': [1000, -200, 500]\n})\n\n# Display the first few rows of the DataFrame\nprint(transactions.head())\nprint (\"\\n\")\n# Calculating the total balance after transactions\ntransactions['Balance'] = transactions['Amount'].cumsum()\nprint(transactions)\n\n\n\n3.3 matplotlib and seaborn for Data Visualization\nmatplotlib and seaborn are powerful libraries for creating visualizations. matplotlib provides a flexible foundation, while seaborn simplifies the creation of more complex plots.\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Example: Visualizing the account balances over time\nsns.lineplot(x='Date', y='Balance', data=transactions)\nplt.title(\"Account Balance Over Time\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Balance\")\nplt.xticks(rotation=45)\nplt.show()\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Sample Data: Tips Dataset (comes built-in with seaborn)\ndata = sns.load_dataset(\"tips\")\n\n# Create a rich visualization using Seaborn's relplot\nsns.set_theme(style=\"whitegrid\")  # Set theme for aesthetics\nplot = sns.relplot(\n    data=data, \n    x=\"total_bill\", \n    y=\"tip\", \n    hue=\"day\", \n    style=\"time\", \n    size=\"size\",\n    palette=\"viridis\", \n    kind=\"scatter\", \n    aspect=1.5,\n    height=6\n)\n\n# Add labels and a title\nplot.set_axis_labels(\"Total Bill ($)\", \"Tip ($)\")\nplot.fig.suptitle(\"Tips vs. Total Bill by Day and Time\", fontsize=16, weight='bold')\n\n# Show the plot\nplt.show()\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load the built-in 'iris' dataset from seaborn\niris = sns.load_dataset(\"iris\")\n\n# Create a pairplot with rich formatting\nsns.set(style=\"ticks\", palette=\"pastel\")\n# pairplot() visualizes pairwise relationships in a dataset, making it great for exploratory data analysis.\nplot = sns.pairplot(\n    iris, \n    hue=\"species\",  # Color by species type\n    kind=\"reg\",     # Add regression lines to show trends\n    diag_kind=\"kde\",  # Use KDE plots on the diagonal for a smoother distribution\n    markers=[\"o\", \"s\", \"D\"],  # Use different markers for each species\n    height=2.5\n)\n\n# Add a main title and adjust spacing\nplot.fig.suptitle(\"Pairplot of Iris Dataset with Regression Lines\", fontsize=16, weight='bold')\nplot.fig.subplots_adjust(top=0.95)\n\n# Display the plot\nplt.show()\n\n\n\n3.4 datetime for Date and Time Manipulation\nThe datetime module allows you to work with dates and times.\n\nfrom datetime import datetime\n\n# Example: Calculating the number of days between two dates\ndate_format = \"%Y-%m-%d\"\nstart_date = datetime.strptime(\"2023-08-01\", date_format)\nend_date = datetime.strptime(\"2023-08-10\", date_format)\n\ndays_between = (end_date - start_date).days\nprint(f\"Days between {start_date.date()} and {end_date.date()}: {days_between}\")"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Course Information",
    "section": "",
    "text": "Professor: Tarik Roukny (tarik.roukny@kuleuven.be)\nLectures: Wednesdays\n\nTime blocks for sessions\n\n08.30 AM - 10.30 AM\n10.30 PM - 12.30 PM\n\nRoom HER1 - 04.4207\n\nOffice hours: by email appointment."
  },
  {
    "objectID": "syllabus.html#prerequisites",
    "href": "syllabus.html#prerequisites",
    "title": "Course Information",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis is a beginner’s course for programming: no prior computer skills are required\n\nKnowledge of statistics and basic econometrics is required\nKnowledge of Financial Markets and Institutions and Corporate Finance is advised"
  },
  {
    "objectID": "syllabus.html#content",
    "href": "syllabus.html#content",
    "title": "Course Information",
    "section": "Content",
    "text": "Content\n\nIntroduction to Scientific Programming\n\nProgramming Environment\nNotebooks\nBasics of Python Programming Language\n\nData Manipulation\n\nData Analytics\nData Treatment\nData Visualization\n\nApplying Data Science in Finance\n\nTime series\nNetwork Analysis\nMachine Learning"
  },
  {
    "objectID": "syllabus.html#delivery",
    "href": "syllabus.html#delivery",
    "title": "Course Information",
    "section": "Delivery",
    "text": "Delivery\nMaterial is delivered through Jupyter Notebooks. The presentation format of files is ‘.ipynb’ and can be read from the Jupyter interface or other services. Notebooks are interactive and can be used off-the-shell to run code. Static and printable version in pdf and HTML of the material are also available."
  },
  {
    "objectID": "syllabus.html#reference",
    "href": "syllabus.html#reference",
    "title": "Course Information",
    "section": "Reference",
    "text": "Reference\nPython for Finance, 2nd Edition by Yves Hilpisch"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science For Finance",
    "section": "",
    "text": "This website accompanies the course of Data Science For Finance (B-KUL-HMA99A)."
  },
  {
    "objectID": "index.html#news-announcements",
    "href": "index.html#news-announcements",
    "title": "Data Science For Finance",
    "section": "News & Announcements",
    "text": "News & Announcements\n\n14/10/2025\n\nRecordings for Lecture 05 and 06 are available\nSolutions to Problem set of Lecture 03 and 04 are available\n\n\n\n\n07/10/2025\n\nRecordings for Lecture 03 and 04 are available\nSolutions to Problem set of Lecture 02 are available\nNew: A beta test All Day TA is available for the course.\n\nAll Day TA is an interactive AI tutor trained on the course material and synced with the course schedule for learning support.\n\n\n\n\n\n01/10/2025\n\nRecordings for Introduction, and Lecture 01 and 02 are available\nSolutions to Problem set of Lecture 02 will be available next week\n\n\n\n\n25/09/2025\n\nThe course is live\nMaterial for Lecture 01 and 02 is available"
  },
  {
    "objectID": "lectures/lecture_06/lecture_06.html",
    "href": "lectures/lecture_06/lecture_06.html",
    "title": "Lecture 06 - Libraries",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_06/lecture_06.html#lecture-material",
    "href": "lectures/lecture_06/lecture_06.html#lecture-material",
    "title": "Lecture 06 - Libraries",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_06/lecture_06.html#recording",
    "href": "lectures/lecture_06/lecture_06.html#recording",
    "title": "Lecture 06 - Libraries",
    "section": "Recording",
    "text": "Recording"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html",
    "href": "lectures/lecture_01/introduction_to_python.html",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its simplicity and readability.\nKey Features of Python\n\nEasy to Learn: Python’s syntax is straightforward.\nInterpreted Language: Python code is executed line by line, which makes debugging easier.\nDynamically Typed: You don’t need to declare variable types explicitly; Python handles it automatically.\nVersatile: Python is used in web development, data analysis, automation, and much more.\nHuge Ecosystem: Python has a large standard library and third-party modules for a wide variety of applications.\n\n\n\n\n\nData Handling: In finance, you often work with large datasets—Python’s libraries like pandas and NumPy are designed to handle and analyze financial data efficiently.\nAutomation: Python can automate repetitive tasks like data retrieval, report generation, and portfolio analysis.\nFinancial Modeling: Python is a great tool for building complex models such as forecasting, risk management, and pricing.\nIntegration with Data Science: Python is the most popular language for data science, offering extensive support for statistical analysis, machine learning, and data visualization."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#what-is-python",
    "href": "lectures/lecture_01/introduction_to_python.html#what-is-python",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its simplicity and readability.\nKey Features of Python\n\nEasy to Learn: Python’s syntax is straightforward.\nInterpreted Language: Python code is executed line by line, which makes debugging easier.\nDynamically Typed: You don’t need to declare variable types explicitly; Python handles it automatically.\nVersatile: Python is used in web development, data analysis, automation, and much more.\nHuge Ecosystem: Python has a large standard library and third-party modules for a wide variety of applications."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#why-python-for-finance",
    "href": "lectures/lecture_01/introduction_to_python.html#why-python-for-finance",
    "title": "Lecture 01 - Introduction to Python",
    "section": "",
    "text": "Data Handling: In finance, you often work with large datasets—Python’s libraries like pandas and NumPy are designed to handle and analyze financial data efficiently.\nAutomation: Python can automate repetitive tasks like data retrieval, report generation, and portfolio analysis.\nFinancial Modeling: Python is a great tool for building complex models such as forecasting, risk management, and pricing.\nIntegration with Data Science: Python is the most popular language for data science, offering extensive support for statistical analysis, machine learning, and data visualization."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#installing-a-python-environment",
    "href": "lectures/lecture_01/introduction_to_python.html#installing-a-python-environment",
    "title": "Lecture 01 - Introduction to Python",
    "section": "2.1 Installing a Python environment",
    "text": "2.1 Installing a Python environment\n\nPython\n\nDownload Python from the official website.\nInstallation includes the Python interpreter and Integrated Development Environment (IDLE) for coding.\n\n\n\nInstalling Anaconda\n\nAnaconda is a suite of useful tools and packages for Python development.\nDownload Anaconda from the official website\nOnce it is installed, confirm the following environments and packages are available:\n\nSpyder\nJupyter Notebook"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#running-python-code",
    "href": "lectures/lecture_01/introduction_to_python.html#running-python-code",
    "title": "Lecture 01 - Introduction to Python",
    "section": "2.2 Running Python Code",
    "text": "2.2 Running Python Code\nThere are multiple ways to run Python.\nConsider the following code line which instructs to simply print out “Hello World!”\n    print (\"Hello World!\")\n\nPython Shell\n\nUse the Python IDLE (from terminal of from any IDE setting like Spyder)\nType the code and press Enter\nCheck the output\n\n\n\nPython Script\n\nOpen an empty file (Spyder, Sublime Text Editor, etc.)\nWrite the code\nSave file as helloworld.py\nRun the script\n\nFrom the terminal, run the script by typing\n\n    python helloworld.py\n\nFrom the IDE (like Spyder), launch the run\n\nCheck the output\n\n\n\nNotebook\n\nThis is a Notebook\n\nPlatforms like Jupyter Notebooks are widely used in data science for documenting and running code interactively. - Open Jupyter Notebook by typing in the terminal\n    Jupyter Notebook\n\nCreat a new notebook with a Python environment\nWrite the code in the first cell\nRun the cell\nCheck the output (see below)\n\n\nprint ('Hello World!')"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#syntax",
    "href": "lectures/lecture_01/introduction_to_python.html#syntax",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.1 Syntax",
    "text": "3.1 Syntax\n\n3.1.1 Python as a calculator\n\n5000 + 250\n\n\n10000 * 1.05\n\n\n10000 / 2\n\nComments: Use comments (#) to explain code, particularly useful for documenting underlying logic.\n\n# Basic financial arithmetic\nprint(5000 + 250)    # Adding investment returns\nprint(10000 * 1.05)  # Calculating interest (5% growth)\nprint(10000 / 2) # Splitting an investment\n\n\n# This is a comment\nprint(\"Welcome to Python for Finance!\")  # This prints a message\n\n\n\n3.1.2 Variables and Data Types\n\nVariables\nVariables are store data for calculations\nThe operation = assigns a value to a variable.\n\n# Variable assignment in a financial scenario\nstock_price = 150.25  # Price of a stock\ninvestment_amount = 10000  # Amount invested\nshares = investment_amount / stock_price  # Number of shares\n\n\nshares\n\n\n\nData types\nVariables can be of different types.\n\nStrings (str): Text\nIntegers (int): Integer value\nFloats (float): Real value\nBooleans (bool): True or False\n\nBecause Python is dynamically typed, there is no need to explicitly mention the type of the variable. Yet, in some cases, it may be important to cast variables from one type to another.\nMore on this in the next lecture."
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#control-structures",
    "href": "lectures/lecture_01/introduction_to_python.html#control-structures",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.2 Control structures",
    "text": "3.2 Control structures\nControl structures allow to condition the sequence of action of a code on the particular value a variable exhibits at the time of execution.\n\nConditional statements\nLoops\n\nNote: tabs are organizational pillars of the Python code structure\n\n3.2.1 Conditional statements\nConditional statements consider the specific value of a variable at the time of execution and determine the outcome based on a logical operation.\nStructure\n    If CONDITON HOLDS:\n        OUTCOME 1\n    Elif OTHER CONDITION HOLDS:\n        OUTCOME 2\n    Else:\n        OUTCOME 3\nNote: check the tabs\n\nbalance = 5000\nif balance &gt;= 10000:\n    print(\"You are eligible for premium services.\")\nelse:\n    print(\"Standard services apply.\")\n\n\n\n3.2.2 Loops\nLoops repeat a sequence of actions until a condition is satisfied. There are two types of loops:\n\nwhile\nfor\n\n\nWhile\nStructure\n    While CONDITION HOLDS:\n        ACTION(s)\n\n# Use case: Simulating monthly deposit growth\nbalance = 1000\nmonths = 0\nwhile balance &lt; 2000:\n    balance += 100  # Monthly deposit\n    months += 1\nprint(f\"It took {months} months to double the balance.\")\n\n\n\nFor\nStructure\n    For CONDITION HOLDS | Increment action:\n        ACTION(s)\n\n# Use case: Summing up daily returns from a list\ndaily_returns = [0.01, -0.02, 0.03, 0.02, -0.01]\ntotal_return = 0\nfor r in daily_returns:\n    total_return += r\nprint(\"Total return for the week:\", total_return)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#functions",
    "href": "lectures/lecture_01/introduction_to_python.html#functions",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.3 Functions",
    "text": "3.3 Functions\nA function is a reusable block of code that is saved up and can be called at multiple places in the main script.\nStructure\n    def my_function (parameters):\n        ACTION(s)\n        return VALUE\n\n# Function to calculate compound interest\ndef calculate_compound_interest(principal, rate, time):\n    return principal * (1 + rate) ** time\n\n\n# Example usage\nresult = calculate_compound_interest(1000, 0.05, 5)\nprint(\"Compound Interest:\", result)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#data-structures",
    "href": "lectures/lecture_01/introduction_to_python.html#data-structures",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.4 Data structures",
    "text": "3.4 Data structures\n\n3.4.1 Lists\nLists allow to store and treat mutliple data points into one variable\n\n# Example: List of daily stock prices\nstock_prices = [150.25, 153.50, 152.00, 155.00]\nprint(stock_prices[0])  # Accessing the first day's price\nstock_prices.append(157.25)  # Adding a new day's price\nprint(stock_prices)\n\n\n\n3.4.2 Dictionaries\nDictionnaries allow store and treat multiple pairs of data point associating keys and values.\n\n# Example: Dictionary to store portfolio allocation\nportfolio = {\n    \"AAPL\": 5000,\n    \"GOOGL\": 3000,\n    \"AMZN\": 2000\n}\nprint(portfolio[\"AAPL\"])  # Accessing allocation for AAPL\nportfolio[\"GOOGL\"] += 1000  # Updating allocation for GOOGL\nprint(portfolio)"
  },
  {
    "objectID": "lectures/lecture_01/introduction_to_python.html#libraries",
    "href": "lectures/lecture_01/introduction_to_python.html#libraries",
    "title": "Lecture 01 - Introduction to Python",
    "section": "3.5 Libraries",
    "text": "3.5 Libraries\nLibraries are pre-built packages of functions for tasks like data analysis and visualization.\n\nKey Libraries for Finance\n\nNumPy: For numerical computations matrix operations in portfolio analysis\npandas: Used for data manipulation handling financial datasets\nmatplotlib: For data visualization plotting stock prices\n\n\nimport numpy \n\nprint(numpy.sqrt(16))  # Square root\nprint(numpy.pi)        # Value of pi\n\n\n\nDocumentation\nLibraries come with documentation.\nOn Notebooks, they can be directly accessed from the cell pressing maj + tab after the function.\n\nExample of documentation numpy.sqrt()\n    Call signature:  numpy.sqrt(*args, **kwargs)\nType:            ufunc\nString form:     &lt;ufunc 'sqrt'&gt;\nFile:            ~/opt/anaconda3/lib/python3.9/site-packages/numpy/__init__.py\nDocstring:      \nsqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.\n\nParameters\n----------\nx : array_like\n    The values whose square-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlib.scimath.sqrt\n    A version which returns complex numbers when given negative reals.\n\nNotes\n-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\n\nExamples\n--------\n&gt;&gt;&gt; np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n&gt;&gt;&gt; np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n&gt;&gt;&gt; np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])\nClass docstring:\nFunctions that operate element by element on whole arrays.\n\nTo see the documentation for a specific ufunc, use `info`.  For\nexample, ``np.info(np.sin)``.  Because ufuncs are written in C\n(for speed) and linked into Python with NumPy's ufunc facility,\nPython's help() function finds this page whenever help() is called\non a ufunc.\n\nA detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.\n\n**Calling ufuncs:** ``op(*x[, out], where=True, **kwargs)``\n\nApply `op` to the arguments `*x` elementwise, broadcasting the arguments.\n\nThe broadcasting rules are:\n\n* Dimensions of length 1 may be prepended to either array.\n* Arrays may be repeated along dimensions of length 1.\n\nParameters\n----------\n*x : array_like\n    Input arrays.\nout : ndarray, None, or tuple of ndarray and None, optional\n    Alternate array object(s) in which to put the result; if provided, it\n    must have a shape that the inputs broadcast to. A tuple of arrays\n    (possible only as a keyword argument) must have length equal to the\n    number of outputs; use None for uninitialized outputs to be\n    allocated by the ufunc.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.\n\nReturns\n-------\nr : ndarray or tuple of ndarray\n    `r` will have the shape that the arrays in `x` broadcast to; if `out` is\n    provided, it will be returned. If not, `r` will be allocated and\n    may contain uninitialized values. If the function has more than one\n    output, then the result will be a tuple of arrays."
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html",
    "href": "lectures/lecture_02/lecture_02.html",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#lecture-material",
    "href": "lectures/lecture_02/lecture_02.html#lecture-material",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#recording",
    "href": "lectures/lecture_02/lecture_02.html#recording",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "Recording",
    "text": "Recording\n\n1. Types\n\n \n\n\n\n2. Structures"
  },
  {
    "objectID": "lectures/lecture_02/lecture_02.html#problem-sets",
    "href": "lectures/lecture_02/lecture_02.html#problem-sets",
    "title": "Lecture 02 - Data Types and Structure",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)\nSolutions (.pdf)"
  },
  {
    "objectID": "lectures/lecture_05/lecture_05.html",
    "href": "lectures/lecture_05/lecture_05.html",
    "title": "Lecture 05 - Object Oriented Programming",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_05/lecture_05.html#lecture-material",
    "href": "lectures/lecture_05/lecture_05.html#lecture-material",
    "title": "Lecture 05 - Object Oriented Programming",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_05/lecture_05.html#recording",
    "href": "lectures/lecture_05/lecture_05.html#recording",
    "title": "Lecture 05 - Object Oriented Programming",
    "section": "Recording",
    "text": "Recording\n\n1. Intro\n\n \n\n\n\n2. Basics\n\n \n\n\n\n3. Inheritance\n\n \n\n\n\n4. Overriding"
  },
  {
    "objectID": "lectures/lecture_05/lecture_05.html#problem-sets",
    "href": "lectures/lecture_05/lecture_05.html#problem-sets",
    "title": "Lecture 05 - Object Oriented Programming",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)"
  },
  {
    "objectID": "lectures/lecture_05/lecture_05_problem_sets.html",
    "href": "lectures/lecture_05/lecture_05_problem_sets.html",
    "title": "Object-Oriented Programming - Problem set",
    "section": "",
    "text": "Problem 1: Create a Book Class\nDefine a Book class with the following attributes: - title (string) - author (string) - pages (integer)\nCreate a method called description() that prints the details of the book in the following format:\n\"&lt;Title&gt; by &lt;Author&gt; has &lt;Pages&gt; pages.\"\n\n# your code\n\n\n\nProblem 2: Create a Rectangle Class\nDefine a Rectangle class with attributes: - length - width\nAdd methods to: - Calculate the area of the rectangle. - Calculate the perimeter of the rectangle.\nCreate a few rectangle objects and call these methods to display their area and perimeter.\n\n# your code\n\n\n\nProblem 3: Create a Circle Class\nDefine a Circle class with a single attribute: - radius\nAdd a method called circumference() that calculates and returns the circumference of the circle (2 * π * radius). Use math.pi for the value of π.\n\n# your code\n\n\n\nProblem 4: Implement a Person Class with Multiple Methods\nCreate a Person class with the following attributes: - name - age - occupation\nAdd methods to: - introduce(): Prints a personalized introduction message: \"Hi, my name is &lt;Name&gt;, and I am a &lt;Occupation&gt;.\" - is_adult(): Returns True if the person is 18 or older, and False otherwise.\n\n# your code\n\n\n\nProblem 5: Create a Library Class\nDefine a Library class that stores a collection of Book objects (from Problem 1). Implement methods to: - Add a new book to the library. - Remove a book from the library using the book title. - List all books currently in the library.\n\n# your code\n\n\n\nProblem 6: Create a BankAccount and CheckingAccount Class Using Inheritance\n\nCreate a BankAccount class with attributes:\n\naccount_holder\nbalance\n\nAdd methods to:\n\ndeposit(amount): Adds money to the account.\nwithdraw(amount): Subtracts money if balance is sufficient; otherwise, prints “Insufficient funds.”\n\nCreate a CheckingAccount class that inherits from BankAccount and has an additional attribute:\n\ntransaction_fee\n\n\nOverride the withdraw() method to include a transaction fee for each withdrawal.\n\n\nProblem 7: Implement a Vehicle and Car Class Using Inheritance\n\nCreate a Vehicle class with attributes:\n\nmake\nmodel\nyear\n\nAdd a method called display_info() that prints the details of the vehicle.\nCreate a Car class that inherits from Vehicle and adds:\n\nfuel_type (e.g., “Petrol” or “Electric”)\n\n\nOverride the display_info() method to include the fuel type in the printed details.\n\n# your code\n\n\n\nProblem 8: Create a Product Class with Inheritance\nCreate a Product base class that represents a generic product in a store. The class should have the following attributes:\n\nname (string)\nprice (float)\n\nCreate two child classes that inherit from Product: 1. Electronics: This class should have an additional attribute called warranty_years (integer). 2. Clothing: This class should have an additional attribute called size (string).\nImplement methods in the base class and child classes as follows: - The base Product class should have a method called display() that prints the product’s name and price. - Each child class should override the display() method to include its additional attributes.\n\nExample of the output format\n&gt;&gt;&gt; electronics = Electronics(\"Smartphone\", 699.99, 2)\n&gt;&gt;&gt; clothing = Clothing(\"T-shirt\", 19.99, \"M\")\n&gt;&gt;&gt; electronics.display()\nProduct: Smartphone, Price: $699.99, Warranty: 2 years\n&gt;&gt;&gt; clothing.display()\nProduct: T-shirt, Price: $19.99, Size: M\n\n# your code\n\n\n\n\nProblem 9: Create a Team Class with Aggregation\nCreate a Player class with attributes: - name - position - number\nCreate a Team class that contains a list of Player objects. Implement methods to: - Add a player. - Remove a player using the player’s name. - Display the list of all players on the team.\n\n# your code\n\n\n\nProblem 10: Polymorphism with a Shape Class Hierarchy\nCreate a Shape parent class with a method draw(). Define two child classes: - Circle class with a draw() method that prints “Drawing a circle.” - Square class with a draw() method that prints “Drawing a square.”\nCreate a list of Shape objects (some Circle and some Square), and use a loop to call draw() on each object, demonstrating polymorphism.\n\n# your code"
  },
  {
    "objectID": "lectures/lecture_04/functions.html",
    "href": "lectures/lecture_04/functions.html",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Functions are a key concept in programming that allow to reuse code, make programs more modular, and simplify complex tasks.\nIn Python, functions are defined using the def keyword.\nThis notebook covers: - Definition and calls - Parameters and arguments - Return values - Scope of variables - Built-in vs. user-defined functions - Functional and anonymous programming"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#overview",
    "href": "lectures/lecture_04/functions.html#overview",
    "title": "Lecture 04 - Functions",
    "section": "",
    "text": "Functions are a key concept in programming that allow to reuse code, make programs more modular, and simplify complex tasks.\nIn Python, functions are defined using the def keyword.\nThis notebook covers: - Definition and calls - Parameters and arguments - Return values - Scope of variables - Built-in vs. user-defined functions - Functional and anonymous programming"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#basics-of-functions",
    "href": "lectures/lecture_04/functions.html#basics-of-functions",
    "title": "Lecture 04 - Functions",
    "section": "1. Basics of Functions",
    "text": "1. Basics of Functions\n\n1.1 Definition and calls\nIn Python, a function is defined using the def keyword followed by the function name and parentheses ().\nOnce implemented, the function is called using the name and parantheses.\nAs long as the function is not called, nothing happens (no output).\n\n# Example of a simple function\ndef greet_bank_customer():\n    print(\"Welcome to ABC Bank!\")\n\n\n# Call the function\ngreet_bank_customer()\n\n\n\n1.2 Arguments\nFunctions can accept inputs, known as arguments or parameters, which are passed into the function using the parentheses.\n\n# Function to calculate simple interest\ndef calculate_simple_interest(principal, rate, time):\n    interest = principal * rate * time / 100\n    print(f\"The interest is: {interest}\")\n\n\n# Call the function with arguments\ncalculate_simple_interest(1000, 5, 2)  # Principal = 1000, Rate = 5%, Time = 2 years\n\n\n\n1.3 Return Values\nFunctions can return a value which can be assigned to an external variable. This obtains from the return statement.\n\n# Function to calculate and return compound interest\ndef calculate_compound_interest(principal, rate, time):\n    amount = principal * (1 + rate/100)**time\n    interest = amount - principal\n    return interest\n\n\n# Call the function and store the result\ncompound_interest = calculate_compound_interest(1000, 5, 2)\nprint(\"The compound interest is:\", compound_interest)\n\n\n\n1.4 Variable Scope\nVariables defined inside a function are local to that function and cannot be accessed outside of it.\nThis is called the scope of a variable.\n\ndef calculate_balance():\n    balance = 5000  # Local variable\n    print(\"Balance inside the function:\", balance)\n\n\ncalculate_balance()\n\n\nprint(balance)  # This will raise an error because balance is not accessible outside the function\n\n\n\n1.5 Built-in vs. User-defined Functions\nPython provides many built-in functions like print(), len(), sum(), etc.\nUser-defined functions can also be used to extend and improve such functions.\n\ntransactions = [100, -50, 200, -100]\ntotal = sum(transactions)\nprint(\"Total balance after transactions:\", total)\n\n\ndef calculate_npv(cash_flows, discount_rate):\n    npv = sum(cf / (1 + discount_rate) ** t for t, cf in enumerate(cash_flows, 1))\n    return npv\n\ncash_flows = [-1000, 200, 300, 400, 500]\nprint(\"Net Present Value:\", calculate_npv(cash_flows, 0.05))"
  },
  {
    "objectID": "lectures/lecture_04/functions.html#functional-programming",
    "href": "lectures/lecture_04/functions.html#functional-programming",
    "title": "Lecture 04 - Functions",
    "section": "2. Functional programming",
    "text": "2. Functional programming\nFunctional programming is a style of programming that treats computation as the evaluation of functions, just like in mathematics.\n\nData is kept unchanged rather than modified\n\nFunctions are written as pure functions: the same input always produces the same output, with no hidden effects\n\nHigher-order functions: can be passed to other functions or returned as results\n\nPython supports functional programming features, making it easy to apply functional programming techniques.\n\ngood practice: Avoiding loops as much as possible and making full use of list comprehensions and functional programming techniques.\n\n\nMath vs. Python Example\nMathematics:\n\\[\nf(x) = x^2\n\\]\n\nInput \\(2 \\rightarrow 4\\)\nInput \\(3 \\rightarrow 9\\)\n\nPython:\ndef f(x):\n    return x**2\n\nf(2)  # 4\nf(3)  # 9\n\n\n2.1 Pure function\nA pure function is a function that: - Always produces the same output given the same input. - Has no side effects (e.g., modifying external variables, changing mutable data, etc.).\nExample of a Pure Function:\n\ndef add(a, b):\n    return a + b\n\nThis function always returns the sum of a and b without modifying anything outside the function.\nNon-Pure Function (with side effects):\n\ntotal = 0\n\ndef add_to_total(amount):\n    global total\n    total += amount\n    return total\n\nThis function modifies the global variable total, which is considered a side effect and makes it a non-pure function.\n\n\n2.2 Higher-order function\nA higher-order function is a function that takes one or more functions as arguments or returns a function as its result.\nExample of a Higher-Order Function:\n\ndef apply_twice(func, value):\n    return func(func(value))\n\ndef double(x):\n    return x * 2\n\nprint(apply_twice(double, 5))\n\n\n\n2.3 Anonymous Functions (lambda)\nIn Python, lambda functions are anonymous functions that can have any number of arguments but only one expression.\nLambdas are useful for short functions without explicit definitions.\nLambda Function Syntax:\nlambda arguments: expression\n\nadd = lambda a, b: a + b\nprint(add(3, 4))  # Output: 7\n\n\n# Lambda function for multiplication\nmultiply = lambda x, y: x * y\nprint(multiply(4, 2))  # Output: 8\n\n\n# Lambda function with if-else to check if a number is even or odd\neven_or_odd = lambda x: 'even' if x % 2 == 0 else 'odd'\nprint(even_or_odd(4))  # Output: even\nprint(even_or_odd(7))  # Output: odd\n\n\n# Convert a string to uppercase using lambda\nto_upper = lambda s: s.upper()\nprint(to_upper('hello'))  # Output: HELLO\n\n\n# Lambda function to calculate the maximum of three numbers\nmax_of_three = lambda a, b, c: a if (a &gt; b and a &gt; c) else (b if b &gt; c else c)\nprint(max_of_three(10, 20, 15))  # Output: 20\n\n\n\n2.4 Functional Programming Tools in Python\nPython provides several built-in functions that are useful in functional programming\n\nmap()\nApplies a given function to each item of an iterable (like a list) and returns a map object.\n\nnumbers = [1, 2, 3, 4, 5]\nsquared_map = map(lambda x: x ** 2, numbers)\nsquared = list(squared_map)\nprint(squared)  \nprint (squared_map)\n\n\n\nfilter()\nFilters items in an iterable based on a given function and returns an iterator.\n\nnumbers = [1, 2, 3, 4, 5, 6]\nevens_iterator = filter(lambda x: x % 2 == 0, numbers)\nevens = list(evens_iterator)\nprint(evens) \nprint(evens_iterator)\n\nNote: iterators in Python are exhausted after one use. Once converted to a list using list(evens_iterator), the iterator is consumed and cannot be used again.\n\n\nreduce()\nPerforms a rolling computation to sequential pairs of values in a list. It requires importing from the functools module.\n\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4]\nresult = reduce(lambda a, b: a * b, numbers)\n# Step 1: 1 * 2 = 2\n# Step 2: 2 * 3 = 6\n# Step 3: 6 * 4 = 24\nprint(result)  \n\n\n\nzip()\nCombines two or more iterables into a single iterable of tuples.\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 90, 95]\n\nzipped = list(zip(names, scores))\nprint(zipped)\n\n\n\nsorted()\nLambda functions can be used to define custom sorting behavior when using sorted().\n\n# Sort a list of tuples based on the second element (using lambda)\npairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\nsorted_pairs = sorted(pairs, key=lambda pair: pair[1])\nprint(sorted_pairs)\n\n\n\nList Comprehension\nAlthough list comprehension is not purely functional, it is closely aligned with functional programming ideas as it allows to create new lists in a concise way.\n\nsquares = [x ** 2 for x in range(5)]\nprint(squares)  # Output: [0, 1, 4, 9, 16]\n\n\n\nDictionaries\nLambda functions can be used to get custom behavior when working with dictionaries, like finding the maximum or minimum key.\n\n# Find the key with the highest value in a dictionary\nscores = {'Alice': 85, 'Bob': 90, 'Charlie': 88}\nhighest_scorer = max(scores, key=lambda k: scores[k])\nprint(highest_scorer)  # Output: Bob\n\nNote: max() and dict:\n1.max(scores): Finds the maximum key (default behavior).\n2.max(scores.values()): Finds the maximum value.\n3.max(scores, key=lambda k: scores[k]): Finds the key corresponding to the maximum value."
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html",
    "href": "lectures/lecture_03/lecture_03.html",
    "title": "Lecture 03 - Control structures",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#lecture-material",
    "href": "lectures/lecture_03/lecture_03.html#lecture-material",
    "title": "Lecture 03 - Control structures",
    "section": "",
    "text": "Notebook\n\nJupyter notebook (.ipynb)\nPage (HTML notebook)\n\nSlides\n\nReveal.js\nPDF"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#recording",
    "href": "lectures/lecture_03/lecture_03.html#recording",
    "title": "Lecture 03 - Control structures",
    "section": "Recording",
    "text": "Recording\n\n1. Intro\n\n \n\n\n\n2. If\n\n \n\n\n\n3. while\n\n \n\n\n\n4. for"
  },
  {
    "objectID": "lectures/lecture_03/lecture_03.html#problem-sets",
    "href": "lectures/lecture_03/lecture_03.html#problem-sets",
    "title": "Lecture 03 - Control structures",
    "section": "Problem sets",
    "text": "Problem sets\n\nJupyter notebook (.ipynb)\nSolutions (.pdf)"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html",
    "href": "lectures/lecture_03/control_structures.html",
    "title": "Lecture 03 - Control Structures",
    "section": "",
    "text": "Control structures are essential in programming: they allow to control the flow of the code.\nIn Python, the primary control structures are if, while, and for loops. These structures are crucial in decision-making processes and repetitive tasks.\nThis notebook covers: - if statements - while loops for repeated execution based on a condition - for loops for iterating over sequences - Counter-based loops - List comprehension"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#overview",
    "href": "lectures/lecture_03/control_structures.html#overview",
    "title": "Lecture 03 - Control Structures",
    "section": "",
    "text": "Control structures are essential in programming: they allow to control the flow of the code.\nIn Python, the primary control structures are if, while, and for loops. These structures are crucial in decision-making processes and repetitive tasks.\nThis notebook covers: - if statements - while loops for repeated execution based on a condition - for loops for iterating over sequences - Counter-based loops - List comprehension"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-if-statement",
    "href": "lectures/lecture_03/control_structures.html#the-if-statement",
    "title": "Lecture 03 - Control Structures",
    "section": "1. The if Statement",
    "text": "1. The if Statement\nThe if statement executes a block of code only if a certain condition is True.\nSuch conditional statements consider the specific value of a variable at the time of execution and determine the outcome based on a logical operation.\n\nStructure\n    If CONDITON HOLDS:\n        OUTCOME 1\n    Elif OTHER CONDITION HOLDS:\n        OUTCOME 2\n    Else:\n        OUTCOME 3\nNote: check the tabs\n\n# Example: withdrawal\nbalance = 500\nwithdrawal_amount = 800\n\nif balance &gt;= withdrawal_amount:\n    balance -= withdrawal_amount\n    print(f\"Withdrawal successful! New balance: {balance}\")\nelse:\n    print(\"Insufficient funds.\")   \n\n\n# Input values\nsavings = float(input(\"Enter your savings amount in dollars: \"))\nmonthly_income = float(input(\"Enter your monthly income in dollars: \"))\ndebt = float(input(\"Enter your debt amount in dollars: \"))\n\n# Applying the conditions using if, elif, and else statements\nif savings &gt; 50000 and debt == 0:\n    print(\"You should invest in stocks.\")\nelif debt &gt; 0 and savings &gt; 20000 and monthly_income &gt; 4000:\n    print(\"You should pay off debt aggressively.\")\nelif savings &lt; 20000 and debt &gt; 10000:\n    print(\"You should save more and minimize spending.\")\nelse:\n    print(\"You should create a budget and build an emergency fund.\")"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-while-loop",
    "href": "lectures/lecture_03/control_structures.html#the-while-loop",
    "title": "Lecture 03 - Control Structures",
    "section": "2. The while Loop",
    "text": "2. The while Loop\nThe while loop repeats a block of code as long as a specified condition is true.\n\n2.1 Structure\n    While CONDITION HOLDS:\n        ACTION(s)\n\n# Example: Simulating a simple ATM withdrawal process\nbalance = 1000\nwithdrawal_attempts = 0\nwithdrawal_amount = 200\n\nwhile balance &gt; 0 and withdrawal_attempts &lt; 3:\n    if balance &gt;= withdrawal_amount:\n        balance -= withdrawal_amount\n        print(f\"Withdrawal successful! New balance: {balance}\")\n    else:\n        print(\"Insufficient funds.\")\n    withdrawal_attempts += 1\n\n\n\n2.2 When using a while loop:\n\nLoop Condition and Termination: Ensure the loop has a valid exit condition that will eventually become False.\n\n\ncount = 0\nwhile count &lt; 5:  # Loop will terminate when count reaches 5\n    print(f\"Count is {count}\")\n    count += 1\n\nIf the loop condition (e.g., count &lt; 5) is never met, the loop will not stop naturally.\n\nUpdate Loop Variable: Ensure the variable controlling the loop is updated to prevent infinite loops.|\n\n\nbalance = 1000\nmonthly_payment = 200\n\nwhile balance &gt; 0:\n    balance -= monthly_payment  # Update balance each iteration\n    print(f\"Remaining balance: ${balance}\")\n\n\nThe balance is reduced each time until it reaches zero, terminating the loop.\n\n\nBreak and Exit Conditions: Use break to exit early when certain conditions are met.\n\n\nwhile True:\n    user_input = input(\"Type 'exit' to stop: \")\n    if user_input == 'exit':\n        print(\"Exiting the loop.\")\n        break\n\n\nThe loop terminates immediately when the user types 'exit'.\n\n\nEfficiency and Performance: Avoid heavy computations inside the loop to maintain performance.\n\n\nn = 1000000\ni = 0\nwhile i &lt; n:\n    i += 1  # Efficient loop, only counting\n# Avoid putting expensive operations here\nprint(f\"Loop completed {n} iterations.\")\n\n\nThe loop is efficient and avoids unnecessary complex calculations inside.\n\n\nEdge Case Handling: Plan for edge cases by adding safety conditions, such as a maximum number of iterations.\n\n\nloan_balance = 5000\nmonthly_payment = 300\nmax_months = 60  # Safety condition to prevent infinite loop\nmonths = 0\n\nwhile loan_balance &gt; 0 and months &lt; max_months:\n    loan_balance -= monthly_payment\n    months += 1\n    if loan_balance &lt; 0:\n        loan_balance = 0\n        break\n\nprint(f\"Loan repaid in {months} months.\")\n\n\nThe loop stops if either the loan is repaid or the maximum number of months is reached.\n\n\n\n2.3 Full example: Loan Repayment Simulation\nSet-up: A user takes out a loan of \\(\\$ 100,000\\) with an annual interest rate of 5%. The user makes fixed monthly payments of \\(\\$ 1,500\\).\nGoal:\n\nCalculate how many months it will take to pay off the loan.\nTrack how much total interest is paid by the time the loan is fully repaid.\n\nTo consider: In this example, we simulate the process of repaying a loan with monthly payments.\nThe goal is to calculate how long it will take to fully repay the loan, considering:\n\nA principal loan amount.\nA fixed monthly payment.\nA monthly interest rate (compound interest).\n\nWe use a while loop to simulate the monthly loan repayment process until the loan is fully repaid. The loop keeps running as long as the loan balance is greater than zero.\n\n# Loan parameters\nprincipal = 100000  # Initial loan amount in dollars\nannual_interest_rate = 0.05  # 5% annual interest\nmonthly_payment = 1500  # Monthly payment in dollars\n\n\n# Calculated monthly interest rate\nmonthly_interest_rate = annual_interest_rate / 12\n\n\n# Initialize variables\nloan_balance = principal  # Remaining loan balance starts as the principal\ntotal_interest_paid = 0  # Track the total interest paid\nmonths = 0  # Track the number of months needed to repay the loan\n\n\n# Loop until the loan is repaid\nwhile loan_balance &gt; 0:\n    # Calculate interest for the current month\n    monthly_interest = loan_balance * monthly_interest_rate\n    total_interest_paid += monthly_interest\n\n    # Update loan balance by subtracting the monthly payment (minus the interest portion)\n    loan_balance = loan_balance + monthly_interest - monthly_payment\n\n    # Increment the number of months\n    months += 1\n\n    # If the loan balance becomes less than the monthly payment in the final month,\n    # pay off the remaining balance and break the loop\n    if loan_balance &lt; monthly_payment:\n        total_interest_paid += loan_balance * monthly_interest_rate  # Final month's interest\n        loan_balance = 0  # Set the balance to 0\n        months += 1  # Add the final month\n\n\n# Output the result\nprint(f\"It will take {months} months to repay the loan.\")\nprint(f\"Total interest paid over the life of the loan: ${total_interest_paid:.2f}\")"
  },
  {
    "objectID": "lectures/lecture_03/control_structures.html#the-for-loop",
    "href": "lectures/lecture_03/control_structures.html#the-for-loop",
    "title": "Lecture 03 - Control Structures",
    "section": "3. The for Loop",
    "text": "3. The for Loop\nThe for loop is used to iterate over a sequence (like a list, tuple, string, etc.) and execute a block of code for each item in the sequence.\n\n3.1 Structure\n    For ITEM in ITERABLE:\n        ACTION(s)\n\nitem: This is a variable that takes the value of each element in the sequence on every iteration.\niterable: This is any Python object that can return one item at a time, like lists, tuples, strings, ranges, etc.\n\nHow It Works\n\nThe for loop goes through each item in the iterable one by one.\nOn each iteration, the item variable is assigned the next value in the sequence, and the block of code inside the loop is executed.\nThis continues until all items in the iterable have been processed.\n\n\nfruits = ['apple', 'banana', 'cherry']\n\nfor fruit in fruits:\n    print(fruit)\n\n\n\n3.2 Looping over lists, dictionnaries and strings\n\nl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfor element in l[2:5]:\n    print (element ** 2)\n\n\nd = {\n    \"program\": \"Master of Business Administration\",\n    \"year\": 2025,\n    \"number_of_students\": 42,\n    \"average_age\": 22,\n    \"specializations\": [\"Finance\", \"Marketing\", \"Data Science\", \"Strategy\"]\n}\nfor item in d.items():\n    print (item)\n\n\nfor value in d.values():\n    print (type(value))\n\n\n# Example: Calculating the total balance from a list of transactions\ntransactions = [100, -50, 200, -75, 150]\ntotal_balance = 0\n\nfor transaction in transactions:\n    total_balance += transaction\n\nprint(\"Total balance after all transactions:\", total_balance)\n\n\n# Looping over strings\nmessage = \"Hello\"\n\nfor char in message:\n    print(char)\n\n\n\n3.3 Counter-based looping\nThe range() function is often used in for loops when you need to loop a specific number of times or generate a sequence of numbers.\n\nr = range(0, 8, 1)\nr\n\n\nlist(r)\n\n\ntype (r)\n\n\nfor i in range(5):\n    print(i)\n\n\nrange(5) generates a sequence of numbers from 0 to 4.\nOn each iteration, the variable i takes the value of the next number in the range.\n\n\nfor i in range(2,5):\n    print (l[i] ** 2)\n\n\n\n3.4 Nested for loops\nfor loops can be nested to iterate over multi-dimensional data structures like lists of lists or matrices:\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nfor row in matrix:\n    for item in row:\n        print(item, end=\" \")\n    print()  # Newline after each row\n\nIn this case: - The first line: for row in [[1, 2], [3, 4], [5, 6]] iterates over each row of the matrix. - The second line: for item in row iterates over each item in the row. - The item expression adds the individual elements to the new list.\n\n\n3.5 break and continue and else\n\nbreak: Exits the loop prematurely when a certain condition is met.\ncontinue: Skips the current iteration and moves on to the next iteration.\nelse: Executes after the loop completes normally (i.e., when the loop is not terminated by a break statement).\n\n\nfor num in range(1, 10):\n    if num == 5:\n        break  # Exit the loop when num equals 5\n    print(num)\n\n\nfor num in range(1, 6):\n    if num == 3:\n        continue  # Skip the iteration when num equals 3\n    print(num)\n\n\nfor num in range(1, 5):\n    print(num)\nelse:\n    print(\"Loop completed.\")\n\n\n# If the loop is interrupted by a break, the else block is not executed:\nfor num in range(1, 5):\n    if num == 3:\n        break\n    print(num)\nelse:\n    print(\"Loop completed.\")\n\n\n\n3.6 Looping and conditioning\n\nfor i in range (1,10):\n    if i % 2 == 0:\n        print (i, 'is even')\n    elif i % 3 == 0:\n        print (i, 'is a multiple of 3')\n    else:\n        print (i, 'is odd')\n\n\n\n3.7 List comprehension\nList comprehension is a concise way to create lists in Python. It combines a for loop and optional conditions into a single line of code, allowing to generate lists quickly and efficiently.\nIt is not only shorter but often more readable and efficient computationally than traditional for loops when dealing with list generation.\n\nBasic Syntax of List Comprehension\nnew_list = [expression for item in iterable if condition]\n\nexpression: The value to append to the new list.\nitem: The variable representing each element in the iterable (e.g., list, string, or range).\niterable: Any sequence or collection being iterated over (e.g., a list, tuple, string, or range).\ncondition: (Optional) A filter that includes only certain elements from the iterable. The condition is an if statement.\n\n\n#  Traditional `for` Loop:\nnumbers = [1, 2, 3, 4, 5]\nsquares = []\n\nfor number in numbers:\n    squares.append(number ** 2)\n\nprint(squares)\n\n\n# Equivalent List Comprehension:\nsquares = [number ** 2 for number in [1, 2, 3, 4, 5]]\nprint(squares)\n\nIn this case: - The for number in [1, 2, 3, 4, 5] part is the iteration. - The number ** 2 part is the expression that generates the square of each number.\n\n\nList comprehesions with condition\nif statement can be included in a list comprehension to filter elements.\n\n# Traditional `for` Loop with Condition:\nnumbers = [1, 2, 3, 4, 5, 6]\nevens = []\n\nfor number in numbers:\n    if number % 2 == 0:\n        evens.append(number)\n\nprint(evens)\n\n\n# Equivalent list comprehension with condition:\nevens = [number for number in [1, 2, 3, 4, 5, 6] if number % 2 == 0]\nprint(evens)\n\n\n# List comprehension with multiple conditions\nfiltered_numbers = [number for number in range(1, 21) if number % 2 == 0 and number % 3 == 0]\nprint(filtered_numbers)\n\n\n\nList comprehension with function calls\nFunction calls can be used in the expression part of a list comprehension.\n\ndef square(number):\n    return number ** 2\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = [square(number) for number in numbers]\n\n\n\nDictionary with list comprehension\nList comprehensions can be used to create dictionaries using the dict() constructor.\n\nnames = ['Alice', 'Bob', 'Charlie']\nname_length_dict = {name: len(name) for name in names}\n\nprint(name_length_dict)\n\n\n\nWhen to use list comprehensions\n\nConciseness: Generate lists quickly and concisely.\nReadability: For simple iterations, list comprehension is often more readable than multiple lines of for loops.\nEfficiency: List comprehensions are more efficient than traditional loops due to optimizations in Python’s internal implementation.\n\n\n\nWhen Not to Use List Comprehension\n\nComplex Logic: If the logic inside the list comprehension becomes too complex (e.g., multiple if conditions, nested loops), it may become less readable. In such cases, traditional loops may be clearer.\nSide Effects: List comprehensions should not be used if the logic involves side effects (e.g., modifying external variables or data structures), as they are primarily designed for list generation, not process flow control."
  }
]